<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Voxel Logo - Combined Spin & Logo Reveal</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: radial-gradient(
          120% 120% at 20% 20%,
          #111a2d 0%,
          #0a0d14 55%,
          #05070e 100%
        );
        color: #cfd7ff;
        overflow: hidden;
      }

      .hero {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      .canvas-container {
        width: 100%;
        height: 100%;
      }

      #voxelCanvas {
        width: 100%;
        height: 100%;
        display: block;
        cursor: crosshair;
      }
    </style>
  </head>
  <body>
    <section class="hero">
      <div class="canvas-container">
        <canvas id="voxelCanvas"></canvas>
      </div>
    </section>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      /**
       * QUICK ORIENTATION
       * - Paths: LOGO_PATH_CONFIG + CLOUD_SHAPE generate voxel positions.
       * - VoxelLogo class stages:
       *   1) appear      → three clouds drop in + rods fade
       *   2) idle_clouds → subtle float, 3 rods
       *   3) spin_add_cloud → 360° spin, 4th cloud grows in, 6 rods
       *   4) hold_four   → breathing hold with 4 clouds connected
       *   5) spin_to_logo → 360° spin, all voxels morph into ring logo
       *   6) hold_logo   → logo hover, rods off
       *   7) spin_back_clouds → 360° spin, logo dissolves back to 3 clouds, extra fades
       *   8) hold_clouds → short rest before looping to step 3
       * - Tune timings in this.timing inside VoxelLogo.
       */
      const LOGO_PATH_CONFIG = [
        // =========================================================
        // STROKE 0 (Blue) – Left "C" shape
        // =========================================================
        {
          strokeIndex: 0,
          segments: [
            {
              type: "cubic",
              segments: 10,
              c0: { x: 280.68, y: 493.55 },
              c1: { x: 271.39, y: 495.49 },
              c2: { x: 264.7, y: 496.18 },
              c3: { x: 252.5, y: 496.45 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 252.5, y: 496.45 },
              c1: { x: 234.35, y: 496.85 },
              c2: { x: 232.49, y: 496.71 },
              c3: { x: 218.0, y: 493.9 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 218.0, y: 493.9 },
              c1: { x: 156.62, y: 481.99 },
              c2: { x: 107.56, y: 434.17 },
              c3: { x: 93.44, y: 372.5 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 93.44, y: 372.5 },
              c1: { x: 89.53, y: 355.43 },
              c2: { x: 88.84, y: 329.02 },
              c3: { x: 91.84, y: 311.41 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 91.84, y: 311.41 },
              c1: { x: 103.11, y: 245.28 },
              c2: { x: 155.02, y: 192.92 },
              c3: { x: 221.12, y: 181.02 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 221.12, y: 181.02 },
              c1: { x: 235.19, y: 178.49 },
              c2: { x: 261.28, y: 178.24 },
              c3: { x: 274.62, y: 180.51 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 274.62, y: 180.51 },
              c1: { x: 294.88, y: 183.97 },
              c2: { x: 319.43, y: 193.09 },
              c3: { x: 326.15, y: 199.65 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 326.15, y: 199.65 },
              c1: { x: 330.89, y: 204.27 },
              c2: { x: 332.35, y: 208.52 },
              c3: { x: 331.8, y: 216.09 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 331.8, y: 216.09 },
              c1: { x: 331.29, y: 223.18 },
              c2: { x: 327.76, y: 228.29 },
              c3: { x: 320.98, y: 231.75 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 320.98, y: 231.75 },
              c1: { x: 314.53, y: 235.04 },
              c2: { x: 310.34, y: 234.63 },
              c3: { x: 298.69, y: 229.57 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 298.69, y: 229.57 },
              c1: { x: 273.87, y: 218.77 },
              c2: { x: 250.8, y: 215.92 },
              c3: { x: 226.01, y: 220.59 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 226.01, y: 220.59 },
              c1: { x: 178.88, y: 229.45 },
              c2: { x: 141.79, y: 266.53 },
              c3: { x: 131.37, y: 315.2 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 131.37, y: 315.2 },
              c1: { x: 129.17, y: 325.48 },
              c2: { x: 128.91, y: 348.54 },
              c3: { x: 130.88, y: 358.0 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 130.88, y: 358.0 },
              c1: { x: 137.4, y: 389.24 },
              c2: { x: 152.75, y: 414.19 },
              c3: { x: 176.3, y: 431.83 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 176.3, y: 431.83 },
              c1: { x: 199.15, y: 448.94 },
              c2: { x: 221.03, y: 456.36 },
              c3: { x: 248.5, y: 456.32 },
            },
            {
              type: "cubic",
              segments: 10,
              c0: { x: 248.5, y: 456.32 },
              c1: { x: 279.3, y: 456.28 },
              c2: { x: 306.7, y: 445.66 },
              c3: { x: 329.29, y: 425.02 },
            },
            {
              type: "cubic",
              c0: { x: 329.29, y: 425.02 },
              c1: { x: 337.97, y: 417.08 },
              c2: { x: 345.5, y: 415.09 },
              c3: { x: 353.77, y: 418.55 },
            },
            {
              type: "cubic",
              c0: { x: 353.77, y: 418.55 },
              c1: { x: 360.8, y: 421.49 },
              c2: { x: 364.3, y: 426.18 },
              c3: { x: 365.52, y: 434.31 },
            },
            {
              type: "cubic",
              c0: { x: 365.52, y: 434.31 },
              c1: { x: 366.75, y: 442.46 },
              c2: { x: 364.43, y: 446.55 },
              c3: { x: 352.47, y: 457.36 },
            },
            {
              type: "cubic",
              c0: { x: 352.47, y: 457.36 },
              c1: { x: 340.81, y: 467.91 },
              c2: { x: 334.73, y: 472.19 },
              c3: { x: 321.54, y: 479.13 },
            },
            {
              type: "cubic",
              c0: { x: 321.54, y: 479.13 },
              c1: { x: 309.28, y: 485.59 },
              c2: { x: 295.41, y: 490.48 },
              c3: { x: 280.68, y: 493.55 },
            },
          ],
        },

        // =========================================================
        // STROKE 1 (Blue) – Cloud + S-curve
        // =========================================================
        {
          strokeIndex: 1,
          segments: [
            {
              type: "cubic",
              c0: { x: 550.5, y: 431.65 },
              c1: { x: 546.66, y: 433.71 },
              c2: { x: 539.6, y: 435.28 },
              c3: { x: 537.5, y: 434.53 },
            },
            {
              type: "cubic",
              c0: { x: 537.5, y: 434.53 },
              c1: { x: 536.95, y: 434.34 },
              c2: { x: 535.25, y: 433.9 },
              c3: { x: 533.72, y: 433.56 },
            },
            {
              type: "cubic",
              c0: { x: 533.72, y: 433.56 },
              c1: { x: 529.76, y: 432.69 },
              c2: { x: 523.56, y: 426.71 },
              c3: { x: 519.82, y: 420.18 },
            },
            {
              type: "cubic",
              c0: { x: 519.82, y: 420.18 },
              c1: { x: 515.17, y: 412.06 },
              c2: { x: 503.09, y: 399.9 },
              c3: { x: 493.13, y: 393.33 },
            },
            {
              type: "cubic",
              c0: { x: 493.13, y: 393.33 },
              c1: { x: 477.31, y: 382.89 },
              c2: { x: 463.24, y: 376.74 },
              c3: { x: 444.4, y: 372.03 },
            },
            {
              type: "cubic",
              c0: { x: 444.4, y: 372.03 },
              c1: { x: 430.65, y: 368.59 },
              c2: { x: 423.58, y: 352.76 },
              c3: { x: 429.94, y: 339.63 },
            },
            {
              type: "cubic",
              c0: { x: 429.94, y: 339.63 },
              c1: { x: 433.21, y: 332.88 },
              c2: { x: 437.38, y: 330.2 },
              c3: { x: 450.79, y: 326.28 },
            },
            {
              type: "cubic",
              c0: { x: 450.79, y: 326.28 },
              c1: { x: 471.84, y: 320.12 },
              c2: { x: 484.51, y: 313.57 },
              c3: { x: 499.04, y: 301.37 },
            },
            {
              type: "cubic",
              c0: { x: 499.04, y: 301.37 },
              c1: { x: 519.33, y: 284.33 },
              c2: { x: 533.68, y: 260.12 },
              c3: { x: 539.02, y: 233.89 },
            },
            {
              type: "cubic",
              c0: { x: 539.02, y: 233.89 },
              c1: { x: 541.29, y: 222.76 },
              c2: { x: 541.77, y: 203.6 },
              c3: { x: 540.05, y: 192.84 },
            },
            {
              type: "cubic",
              c0: { x: 540.05, y: 192.84 },
              c1: { x: 532.57, y: 146.0 },
              c2: { x: 497.94, y: 107.92 },
              c3: { x: 451.29, y: 95.25 },
            },
            {
              type: "cubic",
              c0: { x: 451.29, y: 95.25 },
              c1: { x: 442.24, y: 92.79 },
              c2: { x: 440.03, y: 92.59 },
              c3: { x: 422.0, y: 92.61 },
            },
            {
              type: "cubic",
              c0: { x: 422.0, y: 92.61 },
              c1: { x: 404.19, y: 92.63 },
              c2: { x: 401.66, y: 92.86 },
              c3: { x: 392.87, y: 95.23 },
            },
            {
              type: "cubic",
              c0: { x: 392.87, y: 95.23 },
              c1: { x: 359.36, y: 104.26 },
              c2: { x: 331.39, y: 126.68 },
              c3: { x: 316.79, y: 156.21 },
            },
            {
              type: "cubic",
              c0: { x: 316.79, y: 156.21 },
              c1: { x: 313.04, y: 163.8 },
              c2: { x: 311.06, y: 166.79 },
              c3: { x: 310.0, y: 166.5 },
            },
            {
              type: "cubic",
              c0: { x: 310.0, y: 166.5 },
              c1: { x: 309.17, y: 166.27 },
              c2: { x: 303.95, y: 164.76 },
              c3: { x: 298.39, y: 163.13 },
            },
            {
              type: "cubic",
              c0: { x: 298.39, y: 163.13 },
              c1: { x: 292.84, y: 161.51 },
              c2: { x: 284.74, y: 159.61 },
              c3: { x: 280.39, y: 158.9 },
            },
            {
              type: "cubic",
              c0: { x: 280.39, y: 158.9 },
              c1: { x: 276.05, y: 158.2 },
              c2: { x: 272.39, y: 157.57 },
              c3: { x: 272.26, y: 157.49 },
            },
            {
              type: "cubic",
              c0: { x: 272.26, y: 157.49 },
              c1: { x: 271.61, y: 157.11 },
              c2: { x: 277.49, y: 143.75 },
              c3: { x: 282.08, y: 135.15 },
            },
            {
              type: "cubic",
              c0: { x: 282.08, y: 135.15 },
              c1: { x: 294.59, y: 111.69 },
              c2: { x: 312.28, y: 92.48 },
              c3: { x: 335.31, y: 77.34 },
            },
            {
              type: "cubic",
              c0: { x: 335.31, y: 77.34 },
              c1: { x: 396.76, y: 36.95 },
              c2: { x: 477.68, y: 44.23 },
              c3: { x: 531.21, y: 94.96 },
            },
            {
              type: "cubic",
              c0: { x: 531.21, y: 94.96 },
              c1: { x: 562.23, y: 124.35 },
              c2: { x: 578.9, y: 160.46 },
              c3: { x: 581.62, y: 204.16 },
            },
            {
              type: "cubic",
              c0: { x: 581.62, y: 204.16 },
              c1: { x: 582.99, y: 226.11 },
              c2: { x: 577.35, y: 255.04 },
              c3: { x: 567.54, y: 276.44 },
            },
            {
              type: "cubic",
              c0: { x: 567.54, y: 276.44 },
              c1: { x: 554.84, y: 304.16 },
              c2: { x: 532.1, y: 329.86 },
              c3: { x: 505.32, y: 346.77 },
            },
            {
              type: "cubic",
              c0: { x: 505.32, y: 346.77 },
              c1: { x: 502.94, y: 348.27 },
              c2: { x: 501.01, y: 349.73 },
              c3: { x: 501.02, y: 350.0 },
            },
            {
              type: "cubic",
              c0: { x: 501.02, y: 350.0 },
              c1: { x: 501.04, y: 350.27 },
              c2: { x: 504.57, y: 352.82 },
              c3: { x: 508.87, y: 355.65 },
            },
            {
              type: "cubic",
              c0: { x: 508.87, y: 355.65 },
              c1: { x: 520.01, y: 362.99 },
              c2: { x: 536.0, y: 376.07 },
              c3: { x: 542.03, y: 382.77 },
            },
            {
              type: "cubic",
              c0: { x: 542.03, y: 382.77 },
              c1: { x: 552.73, y: 394.66 },
              c2: { x: 559.97, y: 407.49 },
              c3: { x: 559.99, y: 414.57 },
            },
            {
              type: "cubic",
              c0: { x: 559.99, y: 414.57 },
              c1: { x: 560.01, y: 420.76 },
              c2: { x: 555.42, y: 429.0 },
              c3: { x: 550.5, y: 431.65 },
            },
          ],
        },

        // =========================================================
        // STROKE 2 (Dark) – Right "D" + bottom
        // =========================================================
        {
          strokeIndex: 2,
          segments: [
            {
              type: "cubic",
              c0: { x: 599.5, y: 494.2 },
              c1: { x: 654.95, y: 480.58 },
              c2: { x: 695.66, y: 445.71 },
              c3: { x: 716.07, y: 394.32 },
            },
            {
              type: "cubic",
              c0: { x: 716.07, y: 394.32 },
              c1: { x: 722.72, y: 377.58 },
              c2: { x: 726.08, y: 358.32 },
              c3: { x: 726.07, y: 337.0 },
            },
            {
              type: "cubic",
              c0: { x: 726.07, y: 337.0 },
              c1: { x: 726.02, y: 266.1 },
              c2: { x: 677.94, y: 203.25 },
              c3: { x: 609.12, y: 184.13 },
            },

            {
              type: "line",
              from: { x: 609.12, y: 184.13 },
              to: { x: 601.75, y: 182.08 },
            },
            {
              type: "line",
              from: { x: 601.75, y: 182.08 },
              to: { x: 602.37, y: 186.29 },
            },

            {
              type: "cubic",
              c0: { x: 602.37, y: 186.29 },
              c1: { x: 602.72, y: 188.61 },
              c2: { x: 603.29, y: 198.16 },
              c3: { x: 603.65, y: 207.52 },
            },

            {
              type: "line",
              from: { x: 603.65, y: 207.52 },
              to: { x: 604.3, y: 224.54 },
            },
            {
              type: "line",
              from: { x: 604.3, y: 224.54 },
              to: { x: 611.4, y: 227.38 },
            },

            {
              type: "cubic",
              c0: { x: 611.4, y: 227.38 },
              c1: { x: 641.81, y: 239.56 },
              c2: { x: 666.79, y: 265.29 },
              c3: { x: 678.57, y: 296.58 },
            },
            {
              type: "cubic",
              c0: { x: 678.57, y: 296.58 },
              c1: { x: 686.97, y: 318.91 },
              c2: { x: 688.21, y: 345.79 },
              c3: { x: 681.9, y: 368.72 },
            },
            {
              type: "cubic",
              c0: { x: 681.9, y: 368.72 },
              c1: { x: 676.08, y: 389.86 },
              c2: { x: 665.53, y: 407.48 },
              c3: { x: 649.35, y: 423.06 },
            },
            {
              type: "cubic",
              c0: { x: 649.35, y: 423.06 },
              c1: { x: 632.79, y: 439.02 },
              c2: { x: 616.56, y: 447.98 },
              c3: { x: 593.0, y: 454.18 },
            },
            {
              type: "cubic",
              c0: { x: 593.0, y: 454.18 },
              c1: { x: 584.52, y: 456.42 },
              c2: { x: 584.31, y: 456.42 },
              c3: { x: 485.28, y: 456.75 },
            },

            {
              type: "line",
              from: { x: 485.28, y: 456.75 },
              to: { x: 386.06, y: 457.07 },
            },
            {
              type: "line",
              from: { x: 386.06, y: 457.07 },
              to: { x: 373.46, y: 469.04 },
            },

            {
              type: "cubic",
              c0: { x: 373.46, y: 469.04 },
              c1: { x: 361.69, y: 480.21 },
              c2: { x: 348.29, y: 490.73 },
              c3: { x: 341.09, y: 494.45 },
            },
            {
              type: "cubic",
              c0: { x: 341.09, y: 494.45 },
              c1: { x: 339.39, y: 495.33 },
              c2: { x: 338.0, y: 496.28 },
              c3: { x: 338.0, y: 496.56 },
            },
            {
              type: "cubic",
              c0: { x: 338.0, y: 496.56 },
              c1: { x: 338.0, y: 496.83 },
              c2: { x: 394.81, y: 496.91 },
              c3: { x: 464.25, y: 496.73 },
            },

            {
              type: "line",
              from: { x: 464.25, y: 496.73 },
              to: { x: 590.5, y: 496.41 },
            },
            {
              type: "line",
              from: { x: 590.5, y: 496.41 },
              to: { x: 599.5, y: 494.2 },
            },
          ],
        },
      ];

      const CLOUD_SHAPE = [
        {
          type: "cubic",
          c0: { x: 510.61, y: 302.12 },
          c1: { x: 511.85, y: 340.45 },
          c2: { x: 511.67, y: 330.27 },
          c3: { x: 510.46, y: 335.89 },
        },
        {
          type: "cubic",
          c0: { x: 510.46, y: 335.89 },
          c1: { x: 502.82, y: 371.1 },
          c2: { x: 477.35, y: 397.98 },
          c3: { x: 442.86, y: 407.22 },
        },
        {
          type: "cubic",
          segments: 20,
          c0: { x: 442.86, y: 407.22 },
          c1: { x: 142.94, y: 410.02 },
          c2: { x: 94.95, y: 409.8 },
          c3: { x: 88.04, y: 408.96 },
        },
        {
          type: "cubic",
          c0: { x: 88.04, y: 408.96 },
          c1: { x: 42.67, y: 403.42 },
          c2: { x: 6.27, y: 367.0 },
          c3: { x: 1.12, y: 322.0 },
        },
        {
          type: "cubic",
          c0: { x: 1.12, y: 322.0 },
          c1: { x: 0.97, y: 300.14 },
          c2: { x: 0.98, y: 300.09 },
          c3: { x: 0.99, y: 300.0 },
        },
        {
          type: "cubic",
          c0: { x: 0.99, y: 300.0 },
          c1: { x: 2.6, y: 285.17 },
          c2: { x: 8.4, y: 269.68 },
          c3: { x: 17.43, y: 256.1 },
        },
        {
          type: "cubic",
          c0: { x: 17.43, y: 256.1 },
          c1: { x: 26.21, y: 242.9 },
          c2: { x: 44.59, y: 227.8 },
          c3: { x: 59.7, y: 221.38 },
        },
        {
          type: "cubic",
          c0: { x: 59.7, y: 221.38 },
          c1: { x: 65.46, y: 218.93 },
          c2: { x: 66.01, y: 218.43 },
          c3: { x: 66.52, y: 215.11 },
        },
        {
          type: "cubic",
          c0: { x: 66.52, y: 215.11 },
          c1: { x: 71.31, y: 184.17 },
          c2: { x: 89.21, y: 162.44 },
          c3: { x: 117.0, y: 153.84 },
        },
        {
          type: "cubic",
          c0: { x: 117.0, y: 153.84 },
          c1: { x: 128.5, y: 150.28 },
          c2: { x: 144.44, y: 150.5 },
          c3: { x: 156.26, y: 154.37 },
        },
        {
          type: "cubic",
          c0: { x: 156.26, y: 154.37 },
          c1: { x: 173.72, y: 162.48 },
          c2: { x: 176.39, y: 164.0 },
          c3: { x: 176.56, y: 164.0 },
        },
        {
          type: "cubic",
          c0: { x: 176.56, y: 164.0 },
          c1: { x: 200.84, y: 123.29 },
          c2: { x: 230.53, y: 100.63 },
          c3: { x: 264.71, y: 91.86 },
        },
        {
          type: "cubic",
          c0: { x: 264.71, y: 91.86 },
          c1: { x: 285.33, y: 86.56 },
          c2: { x: 311.47, y: 86.7 },
          c3: { x: 331.91, y: 92.21 },
        },
        {
          type: "cubic",
          c0: { x: 331.91, y: 92.21 },
          c1: { x: 389.41, y: 107.71 },
          c2: { x: 429.55, y: 158.15 },
          c3: { x: 431.61, y: 217.5 },
        },

        // {
        //   type: "line",
        //   from: { x: 432.03, y: 229.5 },
        //   to: { x: 438.26, y: 230.76 },
        // },
        {
          type: "cubic",
          c0: { x: 438.26, y: 230.76 },
          c1: { x: 460.62, y: 235.28 },
          c2: { x: 479.01, y: 246.18 },
          c3: { x: 492.46, y: 262.88 },
        },
        {
          type: "cubic",
          c0: { x: 492.46, y: 262.88 },
          c1: { x: 501.73, y: 274.39 },
          c2: { x: 509.02, y: 290.16 },
          c3: { x: 510.61, y: 302.12 },
        },
      ];

      export const CLOUD_PATH_CONFIG = [
        {
          strokeIndex: 0,
          segments: [...CLOUD_SHAPE],
        },
        {
          strokeIndex: 1,
          segments: [...CLOUD_SHAPE],
        },
        {
          strokeIndex: 2,
          segments: [...CLOUD_SHAPE],
        },
      ];

      // Helper: create N identical cloud strokes (lets us grow to 4 clouds mid-animation)
      const buildCloudPathConfig = (count) =>
        Array.from({ length: count }, (_, idx) => ({
          strokeIndex: idx,
          segments: [...CLOUD_SHAPE],
        }));

      // ============================================
      // Load symbols.png as ASCII Texture
      // ============================================
      function loadSymbolsTexture() {
        return new Promise((resolve) => {
          const loader = new THREE.TextureLoader();
          loader.load(
            "symbols.png",
            (texture) => {
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              resolve({ texture, spriteCount: 10 });
            },
            undefined,
            () => {
              resolve(createFallbackTexture());
            }
          );
        });
      }

      function createFallbackTexture() {
        const chars = " .:-=+*#%@";
        const charWidth = 50;
        const charHeight = 84;
        const canvas = document.createElement("canvas");
        canvas.width = charWidth * chars.length;
        canvas.height = charHeight;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 72px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";

        for (let i = 0; i < chars.length; i++) {
          ctx.fillText(chars[i], charWidth * i + charWidth / 2, charHeight / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return { texture, spriteCount: chars.length };
      }

      // ============================================
      // Easing Functions
      // ============================================
      const ease = {
        cubicInOut: (t) =>
          t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
        backOut: (t) => {
          const c1 = 1.70158;
          const c3 = c1 + 1;
          return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        },
        expoOut: (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t)),
        elasticOut: (t) => {
          if (t === 0 || t === 1) return t;
          return (
            Math.pow(2, -10 * t) *
              Math.sin(((t * 10 - 0.75) * (2 * Math.PI)) / 3) +
            1
          );
        },
        expoInOut: (t) => {
          if (t === 0 || t === 1) return t;
          if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
          return (2 - Math.pow(2, -20 * t + 10)) / 2;
        },
      };

      function fit(value, inMin, inMax, outMin, outMax, easeFunc = null) {
        let t = Math.max(0, Math.min(1, (value - inMin) / (inMax - inMin)));
        if (easeFunc) t = easeFunc(t);
        return outMin + (outMax - outMin) * t;
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      // ============================================
      // Voxel Logo Class - Combined Cloud → Logo story
      // ============================================
      class VoxelLogo {
        constructor(canvas) {
          this.canvas = canvas;
          this.mouseX = 0;
          this.mouseY = 0;
          this.startTime = Date.now();
          this.voxels = [];
          this.appearType = "move";
          this.extraCloudIndex = 3;
          this.prevElapsed = 0;
          this.smoothedCenter = new THREE.Vector3();
          this.spinSmoothedY = 0;
          this.morphBlend = 0;

          // Palette tuned for stronger contrast
          this.color = new THREE.Color("#475882");
          this.bgColor = new THREE.Color("#0F131C");

          // Storyboard phases
          this.phases = [
            "appear",
            "idle_clouds",
            "spin_add_cloud",
            "hold_four",
            "spin_to_logo",
            "hold_logo",
            "spin_back_clouds",
            "hold_clouds",
          ];
          this.loopStartIndex = 2; // after the first reveal, keep looping the spin story
          this.phaseIndex = 0;
          this.phase = this.phases[this.phaseIndex];
          this.phaseStartTime = 0;

          // Spin bookkeeping
          this.spinAngle = 0;
          this.spinStartAngle = 0;
          this.spinTargetAngle = 0;

          // Timing (seconds) for each step in the loop
          this.timing = {
            appear: 1.1,
            idle_clouds: 1.2,
            spin_add_cloud: 1.0,
            hold_four: 3.5,
            spin_to_logo: 1.0,
            hold_logo: 4.0,
            spin_back_clouds: 1.0,
            hold_clouds: 4.0,
          };

          this.init();
        }

        async init() {
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            alpha: true,
            antialias: false,
          });

          this.scene = new THREE.Scene();
          this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
          this.camera.position.z = 5;
          this.scene.add(this.camera);

          this.lightPosition = new THREE.Vector3(2, 2, 2);

          this.pixelScale = 2;
          this.highRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            depthBuffer: true,
          });
          this.lowRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
          });

          const { texture, spriteCount } = await loadSymbolsTexture();
          this.asciiTexture = texture;
          this.spriteCount = spriteCount;

          this.createMaterials();
          this.createVoxelSystem();
          this.createPostProcessing();
          this.bindEvents();
          this.resize();
          this.onPhaseEnter(this.phase);
          this.animate();
        }

        createMaterials() {
          // Blue material for rings 1 & 2 (slightly emissive)
          this.blueMaterial = new THREE.ShaderMaterial({
            uniforms: { u_lightPosition: { value: this.lightPosition } },
            side: THREE.DoubleSide,
            vertexShader: `
                              varying vec3 v_worldPosition;
                              varying vec3 v_worldNormal;
                              varying vec3 v_viewNormal;
                              void main() {
                                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                  v_viewNormal = normalMatrix * normal;
                                  v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                                  v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                              }
                          `,
            fragmentShader: `
                              uniform vec3 u_lightPosition;
                              varying vec3 v_worldPosition, v_worldNormal, v_viewNormal;
                              void main() {
                                  vec3 N = normalize(v_worldNormal);
                                  vec3 L = normalize(u_lightPosition - v_worldPosition);
                                  vec3 V = normalize(v_viewNormal);
                                  float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.38);
                                  float shade2 = max(0.0, dot(V, vec3(0.5773)));
                                  float rim = pow(1.0 - abs(dot(V, N)), 2.0);
                                  float ambient = 0.25;
                                  float glow = 0.25 + rim * 0.4;
                                  float b = ambient + shade1 * 1.2 + shade2 * 1.05 + glow;
                                  gl_FragColor = vec4(b * 0.45, b * 0.75, b * 1.05, 1.0);
                              }
                          `,
          });

          // Dark material for ring 3
          this.darkMaterial = new THREE.ShaderMaterial({
            uniforms: { u_lightPosition: { value: this.lightPosition } },
            side: THREE.DoubleSide,
            vertexShader: `
                              varying vec3 v_worldPosition;
                              varying vec3 v_worldNormal;
                              varying vec3 v_viewNormal;
                              void main() {
                                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                  v_viewNormal = normalMatrix * normal;
                                  v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                                  v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                              }
                          `,
            fragmentShader: `
                              uniform vec3 u_lightPosition;
                              varying vec3 v_worldPosition, v_worldNormal, v_viewNormal;
                              void main() {
                                  vec3 N = normalize(v_worldNormal);
                                  vec3 L = normalize(u_lightPosition - v_worldPosition);
                                  vec3 V = normalize(v_viewNormal);
                                  float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.5);
                                  float shade2 = max(0.0, dot(V, vec3(0.5773)));
                                  float rim = pow(1.0 - abs(dot(V, N)), 2.0);
                                  float ambient = 0.22;
                                  float b = ambient + shade1 * 0.6 + shade2 * 0.6 + rim * 0.4;
                                  gl_FragColor = vec4(b * 0.35, b * 0.45, b * 0.65 + 0.1, 1.0);
                              }
                          `,
          });

          // Cyan rods connecting clouds while they spin
          // this.rodMaterial = new THREE.ShaderMaterial({
          //   uniforms: {
          //     u_lightPosition: { value: this.lightPosition },
          //     u_opacity: { value: 1 },
          //   },
          //   transparent: true,
          //   depthWrite: false,
          //   vertexShader: `
          //                     varying vec3 v_worldPosition;
          //                     varying vec3 v_worldNormal;
          //                     varying vec3 v_viewNormal;
          //                     void main() {
          //                         gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          //                         v_viewNormal = normalMatrix * normal;
          //                         v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
          //                         v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          //                     }
          //                 `,
          //   fragmentShader: `
          //                     uniform vec3 u_lightPosition;
          //                     uniform float u_opacity;
          //                     varying vec3 v_worldPosition, v_worldNormal, v_viewNormal;
          //                     void main() {
          //                         vec3 N = normalize(v_worldNormal);
          //                         vec3 L = normalize(u_lightPosition - v_worldPosition);
          //                         float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.35);
          //                         float shade2 = max(0.0, dot(normalize(v_viewNormal), vec3(0.5773)));
          //                         float brightness = 0.5 + shade1 * 0.35 + shade2 * 0.35;
          //                         gl_FragColor = vec4(brightness * 0.45, brightness * 0.8, brightness * 1.1, clamp(u_opacity, 0.0, 1.0));
          //                     }
          //                 `,
          // });
          this.rodMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_lightPosition: { value: this.lightPosition },
            },
            vertexShader: `
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;

                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            v_viewNormal = normalMatrix * normal;
                            v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                            v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        }
                    `,
            fragmentShader: `
                        uniform vec3 u_lightPosition;
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;

                        void main() {
                            vec3 VN = normalize(v_viewNormal);
                            vec3 N = normalize(v_worldNormal);
                            vec3 L = normalize(u_lightPosition - v_worldPosition);

                            float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.4);
                            float shade2 = max(0.0, dot(VN, vec3(0.5773)));

                            // Bright glow effect
                            float brightness = 0.5 + shade1 * 0.3 + shade2 * 0.3;
                            gl_FragColor = vec4(brightness * 0.5, brightness * 0.7, brightness, 1.0);
                        }
                    `,
          });
        }

        createVoxelSystem() {
          this.logoContainer = new THREE.Object3D();
          this.spinPivot = new THREE.Object3D();
          this.logoOuterContainer = new THREE.Object3D();

          this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);

          // Generate positions for 3 interlocking rings (logo form)
          const offsetX = 380;
          const centerRingByStrokeIndex = [
            { x: -100 + offsetX, y: 0 },
            { x: -85 + offsetX, y: -40 },
            { x: 0 + offsetX, y: 0 },
          ];
          const ringVoxels = this.generateItemPositions(
            LOGO_PATH_CONFIG,
            12,
            centerRingByStrokeIndex,
            true
          );

          // Generate positions for 4 clouds (3 base + 1 that fades in during spin)
          const spread = 3;
          // Adjust these anchors to shift each cloud (laid out as a rhombus; last entry = bonus cloud)
          const cloudCenters = [
            { x: 220, y: -150 }, // top (pull in from edge)
            { x: 0, y: 50 }, // left
            { x: 420, y: 20 }, // right
            { x: 200, y: 200 }, // bottom (appears when we add the 4th cloud)
          ];
          const scaledCloudCenters = cloudCenters.map((p) => ({
            x: p.x * spread,
            y: p.y * spread,
          }));
          const cloudVoxels = this.generateItemPositions(
            buildCloudPathConfig(scaledCloudCenters.length),
            5.8,
            scaledCloudCenters
          );

          console.log("Generated logo voxels:", cloudVoxels);

          this.rods = [];

          this.createRod(cloudVoxels[0][15], cloudVoxels[1][100]); // Top to Left
          this.createRod(cloudVoxels[0][20], cloudVoxels[2][45]); // Top to Right
          this.createRod(cloudVoxels[1][100], cloudVoxels[2][45]); // Left to Right

          // Base anchors for rods and spinning
          this.cloudAnchors = cloudVoxels.map((points) =>
            this.computeAnchor(points)
          );
          this.ringAnchors = ringVoxels.map((points) =>
            this.computeAnchor(points)
          );
          // Map the 4th cloud to the first ring when morphing
          this.ringAnchors.push(this.ringAnchors[0].clone());

          // Create voxel objects with both cloud and ring positions
          const materials = [
            this.blueMaterial,
            this.blueMaterial,
            this.darkMaterial,
          ];

          const groupCount = cloudVoxels.length;
          for (let groupIndex = 0; groupIndex < groupCount; groupIndex++) {
            const ringPositions =
              ringVoxels[groupIndex % ringVoxels.length] || ringVoxels[0];
            const cloudPositions = cloudVoxels[groupIndex];
            const material = materials[groupIndex % materials.length];

            const maxCount = Math.max(
              ringPositions.length,
              cloudPositions.length
            );

            for (let i = 0; i < maxCount; i++) {
              const ringPos = ringPositions[i % ringPositions.length];
              const cloudPos = cloudPositions[i % cloudPositions.length];

              const mesh = new THREE.Mesh(this.boxGeometry, material);
              const container = new THREE.Object3D();
              container.add(mesh);
              this.logoContainer.add(container);

              this.voxels.push({
                container,
                mesh,
                groupIndex,
                cloudPos: { ...cloudPos },
                ringPos: { ...ringPos },
                currentPos: { ...cloudPos },
                scale: 0,
                // delay: groupIndex * 0.25 + i * 0.01,
                delay: groupIndex * 0.25,
              });
            }
          }

          this.logoContainer.scale.setScalar(0.175);
          this.spinPivot.add(this.logoContainer);
          this.logoOuterContainer.add(this.spinPivot);
          this.scene.add(this.logoOuterContainer);
        }
        createRod(from, to) {
          const rod = new THREE.Object3D();

          // Calculate direction and length
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const dz = to.z - from.z;
          const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

          const geometry = new THREE.BoxGeometry(1, 1, 1);

          // Create rod mesh
          const mesh = new THREE.Mesh(geometry, this.rodMaterial);
          const container = new THREE.Object3D();

          // Position at midpoint
          container.position.set(
            (from.x + to.x) / 2,
            (from.y + to.y) / 2,
            (from.z + to.z) / 2
          );

          // Scale to create VISIBLE rod (thicker)
          container.scale.set(0.1, 0.1, length);

          console.log("Rod length:", length);

          // Rotate to point from -> to
          container.lookAt(to.x, to.y, to.z);

          container.add(mesh);
          this.logoContainer.add(container);

          this.rods.push({
            mesh,
            container,
            delay: 1.5 * 0.45,
            length: length,
          });
        }
        generateItemPositions(
          configs,
          defaultScale = 12,
          centerByStrokeIndex = [],
          customZ = false
        ) {
          const strokeCount =
            centerByStrokeIndex.length ||
            Math.max(...configs.map((c) => c.strokeIndex)) + 1 ||
            3;
          const strokes = Array.from({ length: strokeCount }, () => []);
          const voxelSize = 0.07;

          // SVG viewBox: 0 0 826 547, center at ~413, 273
          // Scale and transform SVG coords to our coordinate system
          const svgWidth = 826;
          const svgHeight = 547;
          const scale = defaultScale / svgWidth; // Scale to fit in ~6 units
          const offsetX = -svgWidth / 2;
          const offsetY = -svgHeight / 2;

          const transformX = (x) => (x + offsetX) * scale;
          const transformY = (y) => -(y + offsetY) * scale; // Flip Y axis

          // Helper: Add voxel to stroke (2D, flat)
          const addVoxel = (x, y, strokeIndex) => {
            const rangeLimit = 0.06;
            // const rangeLimit = 1;
            const vx = Math.round(x / voxelSize) * voxelSize;
            const vy = Math.round(y / voxelSize) * voxelSize;

            if (
              !strokes[strokeIndex].some(
                (p) =>
                  Math.abs(p.x - vx) < rangeLimit &&
                  Math.abs(p.y - vy) < rangeLimit
              )
            ) {
              strokes[strokeIndex].push({
                x: vx,
                y: vy,
                z: customZ ? (strokeIndex < 2 ? 1 : 0) : 1,
                size: voxelSize,
              });
            }
          };

          // Helper: Cubic bezier point
          const cubicBezier = (p0, p1, p2, p3, t) => {
            const mt = 1 - t;
            return {
              x:
                mt * mt * mt * p0.x +
                3 * mt * mt * t * p1.x +
                3 * mt * t * t * p2.x +
                t * t * t * p3.x,
              y:
                mt * mt * mt * p0.y +
                3 * mt * mt * t * p1.y +
                3 * mt * t * t * p2.y +
                t * t * t * p3.y,
            };
          };

          // Helper: Generate cubic bezier curve
          const generateCubicBezier = ({
            c0,
            c1,
            c2,
            c3,
            strokeIndex,
            segments = 10,
          }) => {
            const center = centerByStrokeIndex[strokeIndex] || { x: 0, y: 0 };
            const p0 = {
              x: transformX(c0.x + center.x),
              y: transformY(c0.y + center.y),
            };
            const p1 = {
              x: transformX(c1.x + center.x),
              y: transformY(c1.y + center.y),
            };
            const p2 = {
              x: transformX(c2.x + center.x),
              y: transformY(c2.y + center.y),
            };
            const p3 = {
              x: transformX(c3.x + center.x),
              y: transformY(c3.y + center.y),
            };

            // addVoxel(0, 0, strokeIndex);

            for (let i = 0; i <= segments; i++) {
              const t = i / segments;
              const pt = cubicBezier(p0, p1, p2, p3, t);

              addVoxel(pt.x, pt.y, strokeIndex);
            }
            return { x: c3.x, y: c3.y };
          };

          // Helper: Generate line
          const generateLine = (
            fx0,
            fy0,
            fx1,
            fy1,
            strokeIndex,
            segments = 6
          ) => {
            const center = centerByStrokeIndex[strokeIndex] || { x: 0, y: 0 };
            const x0 = fx0 + center.x;
            const y0 = fy0 + center.y;
            const x1 = fx1 + center.x;
            const y1 = fy1 + center.y;
            for (let i = 0; i <= segments; i++) {
              const t = i / segments;

              addVoxel(
                transformX(x0 + (x1 - x0) * t),
                transformY(y0 + (y1 - y0) * t),
                strokeIndex
              );
            }
            return { x: x1, y: y1 };
          };

          // ============================================
          // STROKE 0 (Blue): First path from SVG - Left C + Top bump + S-curve
          // Path: M 550.50 431.65 C... (the complex blue shape)
          // ============================================
          let pos = null;

          for (const stroke of configs) {
            const { strokeIndex, segments } = stroke;

            for (const seg of segments) {
              if (seg.type === "cubic") {
                pos = generateCubicBezier({
                  c0: seg.c0,
                  c1: seg.c1,
                  c2: seg.c2,
                  c3: seg.c3,
                  strokeIndex,
                  segments: seg.segments ?? 10, // default
                });
              }

              if (seg.type === "line") {
                generateLine(
                  seg.from.x,
                  seg.from.y,
                  seg.to.x,
                  seg.to.y,
                  strokeIndex
                );
                pos = seg.to;
              }
            }
          }

          return strokes;
        }

        computeAnchor(points) {
          const center = new THREE.Vector3();
          if (!points.length) return center;
          points.forEach((p) => {
            center.x += p.x;
            center.y += p.y;
            center.z += p.z || 0;
          });
          center.divideScalar(points.length);
          return center;
        }

        // Bezier curve helper function
        bezierCurve(points, segments) {
          const result = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = this.bezierPoint(points, t);
            result.push(point);
          }
          return result;
        }

        bezierPoint(points, t) {
          if (points.length === 1) return points[0];

          const newPoints = [];
          for (let i = 0; i < points.length - 1; i++) {
            newPoints.push({
              x: points[i].x + (points[i + 1].x - points[i].x) * t,
              y: points[i].y + (points[i + 1].y - points[i].y) * t,
              z: points[i].z + (points[i + 1].z - points[i].z) * t,
            });
          }
          return this.bezierPoint(newPoints, t);
        }

        updateRods(anchors = [], opacity = 1) {
          const pairs = [];
          for (let i = 0; i < anchors.length; i++) {
            for (let j = i + 1; j < anchors.length; j++) {
              pairs.push([anchors[i], anchors[j]]);
            }
          }

          // Expand pool if needed
          // while (this.rodPool.length < pairs.length) {
          //   const mesh = new THREE.Mesh(this.rodGeometry, this.rodMaterial);
          //   const container = new THREE.Object3D();
          //   container.add(mesh);
          //   this.rodContainer.add(container);
          //   this.rodPool.push({ mesh, container });
          // }

          // this.rodPool.forEach((rod, idx) => {
          //   if (idx >= pairs.length) {
          //     rod.container.visible = false;
          //     return;
          //   }
          //   const [a, b] = pairs[idx];
          //   const start = a.clone();
          //   const end = b.clone();
          //   const direction = end.clone().sub(start);
          //   const length = Math.max(0.15, direction.length());
          //   const midpoint = start.clone().add(end).multiplyScalar(0.5);

          //   rod.container.visible = opacity > 0.01;
          //   rod.mesh.visible = rod.container.visible;
          //   rod.mesh.material.uniforms.u_opacity.value = opacity;

          //   rod.container.position.copy(midpoint);
          //   rod.container.lookAt(end);
          //   rod.container.scale.set(
          //     this.rodThickness,
          //     this.rodThickness,
          //     length
          //   );
          // });
        }

        createPostProcessing() {
          const quadGeometry = new THREE.PlaneGeometry(2, 2);

          this.postMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_sceneTexture: { value: this.lowRenderTarget.texture },
              u_sceneTextureSize: { value: new THREE.Vector2(1, 1) },
              u_texture: { value: this.asciiTexture },
              u_textureSpriteCount: { value: this.spriteCount },
              u_bgColor: { value: this.bgColor },
              u_color: { value: this.color },
              u_mouseXY: { value: new THREE.Vector2(0, 0) },
              u_resolution: { value: new THREE.Vector2(1, 1) },
              u_brightness: { value: 2.05 },
            },
            vertexShader: `
                              varying vec2 v_uv;
                              void main() {
                                  v_uv = uv;
                                  gl_Position = vec4(position, 1.0);
                              }
                          `,
            fragmentShader: `
                              precision highp float;

                              uniform sampler2D u_sceneTexture;
                              uniform vec2 u_sceneTextureSize;
                              uniform sampler2D u_texture;
                              uniform float u_textureSpriteCount;
                              uniform vec3 u_bgColor;
                              uniform vec3 u_color;
                              uniform vec2 u_mouseXY;
                              uniform vec2 u_resolution;
                              uniform float u_brightness;

                              varying vec2 v_uv;

                              void main() {
                                  vec2 pixelXY = v_uv * u_sceneTextureSize;
                                  vec2 uv = fract(pixelXY);

                                  vec3 pixelRGB = texture2D(u_sceneTexture, floor(pixelXY) / u_sceneTextureSize).rgb;
                                  float luma = max(pixelRGB.g, (1.0 - pixelRGB.b) * 0.5);

                                  float spriteIndex = floor(min(u_textureSpriteCount * luma, u_textureSpriteCount - 1.0));


                                  vec2 spriteUV = vec2((uv.x + spriteIndex) / u_textureSpriteCount, uv.y);

                                  float sprite = texture2D(u_texture, spriteUV).g;

                                  float dist = length(u_mouseXY - vec2(v_uv.x, 1.0 - v_uv.y) * u_resolution);
                                  float distRatio = smoothstep(0.8, 0.0, dist / u_resolution.y) * pixelRGB.r;

                                  vec2 fw = fwidth(uv);
                                  sprite *= 1.0 - min(1.0, fw.x + fw.y);
                                  sprite = smoothstep(0.0, 1.0, sprite * 1.8);

                                  // BRIGHTER output
                                  vec3 brightColor = u_color * u_brightness * (1.0 + distRatio * 3.0);
                                  gl_FragColor = vec4(mix(u_bgColor, min(vec3(1.0), brightColor), sprite), 1.0);
                              }
                          `,
            extensions: { derivatives: true },
          });

          this.postQuad = new THREE.Mesh(quadGeometry, this.postMaterial);
        }

        bindEvents() {
          window.addEventListener("resize", () => this.resize());

          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
          });

          this.canvas.addEventListener("mouseleave", () => {
            this.mouseX = this.domWidth / 2;
            this.mouseY = this.domHeight / 2;
          });
        }

        resize() {
          const rect = this.canvas.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;

          this.domWidth = width;
          this.domHeight = height;

          const pixelSize = fit(height, 400, 1000, 12, 20);

          const pixelHeight = Math.ceil(height / pixelSize);
          const pixelWidth = Math.ceil(width / ((pixelSize * 50) / 84));
          this.lowRenderTarget.setSize(
            pixelWidth * this.pixelScale,
            pixelHeight * this.pixelScale
          );
          this.highRenderTarget.setSize(
            pixelWidth * this.pixelScale,
            pixelHeight * this.pixelScale
          );
          this.postMaterial.uniforms.u_sceneTextureSize.value.set(
            pixelWidth,
            pixelHeight
          );

          const dpr = Math.min(window.devicePixelRatio, 2);
          this.renderer.setSize(width * dpr, height * dpr, false);
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          const aspect = width / height;
          this.camera.left = -aspect;
          this.camera.right = aspect;
          this.camera.updateProjectionMatrix();

          this.mouseX = width / 2;
          this.mouseY = height / 2;
        }

        onPhaseEnter(phase) {
          if (
            phase === "spin_add_cloud" ||
            phase === "spin_to_logo" ||
            phase === "spin_back_clouds"
          ) {
            // Start from current rotation to avoid jumps between phases
            const currentY = this.logoContainer.rotation.y;
            this.spinAngle = currentY;
            this.spinStartAngle = currentY;
            this.spinTargetAngle = currentY - Math.PI * 2; // clockwise to avoid mirrored feel
          }
        }

        onPhaseComplete(phase) {
          if (
            phase === "spin_add_cloud" ||
            phase === "spin_to_logo" ||
            phase === "spin_back_clouds"
          ) {
            this.spinAngle = this.spinTargetAngle;
          }
        }

        updatePhase(elapsed) {
          let phaseTime = elapsed - this.phaseStartTime;
          const duration = this.timing[this.phase] || 1;

          if (phaseTime >= duration) {
            this.onPhaseComplete(this.phase);
            this.phaseIndex += 1;
            if (this.phaseIndex >= this.phases.length) {
              this.phaseIndex = this.loopStartIndex;
            }
            this.phase = this.phases[this.phaseIndex];
            this.phaseStartTime = elapsed;
            this.onPhaseEnter(this.phase);
            phaseTime = 0;
          }

          return { phaseTime, duration };
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const elapsed = (Date.now() - this.startTime) / 1000;
          const delta = this.prevElapsed ? elapsed - this.prevElapsed : 0.016;
          this.prevElapsed = elapsed;
          const { phaseTime, duration } = this.updatePhase(elapsed);
          const phaseProgress = Math.min(1, phaseTime / duration);

          // Update uniforms
          this.postMaterial.uniforms.u_mouseXY.value.set(
            this.mouseX,
            this.mouseY
          );
          this.postMaterial.uniforms.u_resolution.value.set(
            this.domWidth,
            this.domHeight
          );

          // Update light
          const normalizedX = (this.mouseX / this.domWidth) * 2 - 1;
          const normalizedY = 1 - (this.mouseY / this.domHeight) * 2;
          const vec = new THREE.Vector3(normalizedX, normalizedY, 0.5);
          vec.unproject(this.camera);
          vec.z = 5;
          this.lightPosition.copy(vec);

          const mergeProgress =
            this.phase === "spin_to_logo"
              ? ease.cubicInOut(phaseProgress)
              : this.phase === "hold_logo"
              ? 1
              : 0;
          const splitProgress =
            this.phase === "spin_back_clouds"
              ? ease.expoInOut(phaseProgress)
              : 0;

          const extraActivePhases = [
            "spin_add_cloud",
            "hold_four",
            "spin_to_logo",
            "hold_logo",
            "spin_back_clouds",
          ];
          const extraActive = extraActivePhases.includes(this.phase);
          const targetExtraVisibility = extraActive
            ? this.phase === "spin_add_cloud"
              ? ease.cubicInOut(
                  fit(phaseTime, duration * 0.1, duration * 0.9, 0, 1)
                )
              : this.phase === "hold_four" ||
                this.phase === "spin_to_logo" ||
                this.phase === "hold_logo"
              ? 1
              : 1 -
                ease.cubicInOut(
                  fit(phaseTime, duration * 0.1, duration * 0.9, 0, 1)
                )
            : 0;

          // Smoothed extra cloud visibility (prevents phase pop)
          if (this.extraVisibility === undefined) this.extraVisibility = 0;
          const alphaLerp = Math.min(1, delta * 1.5); // slower blend to remove pops
          this.extraVisibility = lerp(
            this.extraVisibility,
            targetExtraVisibility,
            alphaLerp
          );
          const extraVisibility = this.extraVisibility;

          const spinPhases = [
            "spin_add_cloud",
            "spin_to_logo",
            "spin_back_clouds",
          ];
          const inSpin = spinPhases.includes(this.phase);
          const spinProgress = inSpin ? ease.expoInOut(phaseProgress) : 0;
          const targetRotationY = inSpin
            ? lerp(this.spinStartAngle, this.spinTargetAngle, spinProgress)
            : this.spinAngle + Math.sin(elapsed * 0.2) * 0.04;
          const rotLerp = Math.min(1, delta * 4.5);
          this.spinSmoothedY = lerp(
            this.spinSmoothedY,
            targetRotationY,
            rotLerp
          );

          // Slight wobble keeps the voxel stacks lively (reduced for smoothness)
          this.logoContainer.rotation.set(
            -0.05 + Math.sin(elapsed * 0.2) * 0.03,
            this.spinSmoothedY,
            Math.cos(elapsed * 0.16) * 0.03
          );

          // Camera-facing tilt
          this.logoOuterContainer.rotation.set(-0.25, Math.PI * 0.16, 0.06);
          this.logoOuterContainer.position.set(0, 0.02, 0);

          // === Rod logic: temporarily disabled to remove connecting lines ===
          // To re-enable connections, set rodsEnabled = true and adjust opacity below.
          const rodAnchors = []; // empty means no rods drawn
          const rodsEnabled = false;
          const rodOpacity = 0;
          this.updateRods(rodAnchors, rodsEnabled ? rodOpacity : 0);

          // === Center pivot for spinning: keep rotation around the visible mass ===
          const morphRaw =
            this.phase === "spin_to_logo" || this.phase === "hold_logo"
              ? mergeProgress || 1
              : this.phase === "spin_back_clouds"
              ? 1 - splitProgress
              : 0;

          const morphBlendLerp = Math.min(1, delta * 3);
          this.morphBlend = lerp(this.morphBlend, morphRaw, morphBlendLerp);

          const activeAnchors = [];
          this.cloudAnchors.forEach((cloudAnchor, idx) => {
            const ringAnchor = this.ringAnchors[idx % this.ringAnchors.length];
            const isExtra = idx === this.extraCloudIndex;
            const visibility = isExtra ? extraVisibility : 1;
            if (visibility > 0.02) {
              const blended = cloudAnchor
                .clone()
                .lerp(ringAnchor, this.morphBlend);
              activeAnchors.push(blended);
            }
          });

          let center = new THREE.Vector3();
          if (activeAnchors.length) {
            activeAnchors.forEach((a) => center.add(a));
            center.divideScalar(activeAnchors.length);
          }
          // Smooth center to avoid micro-jumps while spinning
          const centerLerp = Math.min(1, delta * 1.2);
          this.smoothedCenter.lerp(center, centerLerp);

          // Re-center the container so spinPivot rotates around the mass center
          this.spinPivot.position.copy(this.smoothedCenter);
          this.logoContainer.position.copy(
            this.smoothedCenter.clone().multiplyScalar(-1)
          );

          if (this.phase === "appear") {
            this.rods.forEach((rod) => {
              const rodTime = phaseTime - rod.delay;

              const appearProgress = Math.max(
                0,
                Math.min(1, (rodTime * 1.5) / (duration - rod.delay))
              );

              const targetScaleZ = rod.length;
              const scaleZ = lerp(0.01, targetScaleZ, appearProgress);

              rod.container.scale.set(0.1, 0.1, scaleZ);
            });
          }

          // Animate voxels based on phase
          this.voxels.forEach((voxel, index) => {
            const isExtra = voxel.groupIndex === this.extraCloudIndex;
            let targetX = voxel.cloudPos.x;
            let targetY = voxel.cloudPos.y;
            let targetZ = voxel.cloudPos.z;
            let scale = isExtra ? extraVisibility : 1;

            const morphDamp = 1 - this.morphBlend * 0.65;
            const bobScale = (isExtra ? extraVisibility : 1) * morphDamp;
            const bobX =
              (Math.sin(elapsed * 2 + index * 0.12) * 0.035 +
                Math.sin(elapsed * 0.7 + voxel.groupIndex) * 0.02) *
              bobScale;
            const bobY =
              (Math.cos(elapsed * 1.6 + index * 0.12) * 0.035 +
                Math.cos(elapsed * 0.5 + voxel.groupIndex) * 0.02) *
              bobScale;

            if (this.phase === "appear") {
              const appearProgress = fit(
                phaseTime,
                voxel.delay * 0.45,
                voxel.delay * 0.45 + 0.9,
                0,
                1,
                ease.expoOut
              );
              const startOffset =
                this.appearType === "scale"
                  ? { x: 0, y: 0, z: 0 }
                  : voxel.groupIndex === 0
                  ? { x: 0, y: 3, z: 0 }
                  : voxel.groupIndex === 1
                  ? { x: -4, y: 0, z: 0 }
                  : { x: 4, y: 0, z: 0 };
              targetX = lerp(
                voxel.cloudPos.x + startOffset.x,
                voxel.cloudPos.x,
                appearProgress
              );
              targetY = lerp(
                voxel.cloudPos.y + startOffset.y,
                voxel.cloudPos.y,
                appearProgress
              );
              targetZ = lerp(
                voxel.cloudPos.z + startOffset.z,
                voxel.cloudPos.z,
                appearProgress
              );
              scale = isExtra ? 0 : appearProgress;
            } else {
              const morph = this.morphBlend;
              targetX = lerp(voxel.cloudPos.x, voxel.ringPos.x, morph);
              targetY = lerp(voxel.cloudPos.y, voxel.ringPos.y, morph);
              targetZ = lerp(voxel.cloudPos.z, voxel.ringPos.z, morph);

              if (morph < 0.999) {
                targetX += bobX;
                targetY += bobY;
              }
            }

            if (this.phase === "spin_add_cloud" && isExtra) {
              scale *= extraVisibility;
            }
            if (this.phase === "hold_logo") {
              scale *= 1.05;
            }

            voxel.container.position.set(targetX, targetY, targetZ);
            let visualScale = Math.max(0, scale);
            if (isExtra && !extraActive) {
              visualScale = 0; // hide the 4th cloud outside active phases
            } else if (visualScale > 0) {
              visualScale = Math.max(0.05, visualScale);
            }
            voxel.container.scale.setScalar(0.62 * visualScale);
          });

          // Render
          this.renderer.setRenderTarget(this.highRenderTarget);
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.clear();
          this.renderer.render(this.scene, this.camera);

          this.copyTexture();

          this.renderer.setRenderTarget(null);
          this.renderer.setClearColor(0x000000, 0);
          this.renderer.clear();
          this.renderer.render(this.postQuad, this.camera);
        }

        copyTexture() {
          const copyMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: this.highRenderTarget.texture } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `uniform sampler2D tDiffuse; varying vec2 vUv; void main() { gl_FragColor = texture2D(tDiffuse, vUv); }`,
          });

          const copyQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            copyMaterial
          );
          this.renderer.setRenderTarget(this.lowRenderTarget);
          this.renderer.render(copyQuad, this.camera);
          copyMaterial.dispose();
          copyQuad.geometry.dispose();
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        document.fonts.ready.then(() => {
          const canvas = document.getElementById("voxelCanvas");
          new VoxelLogo(canvas);
        });
      });
    </script>
  </body>
</html>
