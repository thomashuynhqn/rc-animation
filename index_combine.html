<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Voxel Logo - Combined Spin & Logo Reveal</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: radial-gradient(
          120% 120% at 20% 20%,
          #111a2d 0%,
          #0a0d14 55%,
          #05070e 100%
        );
        color: #cfd7ff;
        overflow: hidden;
      }

      .hero {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      .canvas-container {
        width: 100%;
        height: 100%;
      }

      #voxelCanvas {
        width: 100%;
        height: 100%;
        display: block;
        cursor: crosshair;
      }
    </style>
  </head>
  <body>
    <section class="hero">
      <div class="canvas-container">
        <canvas id="voxelCanvas"></canvas>
      </div>
    </section>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>
    <script src="./config.js"></script>

    <script type="module">
      import * as THREE from "three";

      /**
       * QUICK ORIENTATION
       * - Paths: LOGO_PATH_CONFIG + CLOUD_SHAPE generate voxel positions.
       * - VoxelLogo class stages:
       *   1) appear      → three clouds drop in + rods fade
       *   2) idle_clouds → subtle float, 3 rods
       *   3) spin_add_cloud → 360° spin, 4th cloud grows in, 6 rods
       *   4) hold_four   → breathing hold with 4 clouds connected
       *   5) spin_to_logo → 360° spin, all voxels morph into ring logo
       *   6) hold_logo   → logo hover, rods off
       *   7) spin_back_clouds → 360° spin, logo dissolves back to 3 clouds, extra fades
       *   8) hold_clouds → short rest before looping to step 3
       * - Tune timings in this.timing inside VoxelLogo.
       */

      // Helper: create N identical cloud strokes (lets us grow to 4 clouds mid-animation)
      const buildCloudPathConfig = (count) =>
        Array.from({ length: count }, (_, idx) => ({
          strokeIndex: idx,
          segments: [...CLOUD_SHAPE],
        }));

      // ============================================
      // Load symbols.png as ASCII Texture
      // ============================================
      function loadSymbolsTexture() {
        return new Promise((resolve) => {
          const loader = new THREE.TextureLoader();
          loader.load(
            "symbols.png",
            (texture) => {
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              resolve({ texture, spriteCount: 10 });
            },
            undefined,
            () => {
              resolve(createFallbackTexture());
            }
          );
        });
      }

      function createFallbackTexture() {
        const chars = " .:-=+*#%@";
        const charWidth = 50;
        const charHeight = 84;
        const canvas = document.createElement("canvas");
        canvas.width = charWidth * chars.length;
        canvas.height = charHeight;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold 72px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";

        for (let i = 0; i < chars.length; i++) {
          ctx.fillText(chars[i], charWidth * i + charWidth / 2, charHeight / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return { texture, spriteCount: chars.length };
      }

      // ============================================
      // Voxel Logo Class - Combined Cloud → Logo story
      // ============================================
      class VoxelLogo {
        constructor(canvas) {
          this.canvas = canvas;
          this.mouseX = 0;
          this.mouseY = 0;
          this.startTime = Date.now();
          this.voxels = [];
          this.appearType = "move";
          this.extraCloudIndex = 3;
          this.prevElapsed = 0;
          this.smoothedCenter = new THREE.Vector3();
          this.spinSmoothedY = 0;
          this.morphBlend = 0;

          // Palette tuned for stronger contrast
          this.color = new THREE.Color("#475882");
          this.bgColor = new THREE.Color("#0F131C");

          // Storyboard phases
          this.phases = [
            "appear",
            "idle_clouds",
            "spin_add_cloud",
            "hold_four",
            "spin_to_logo",
            "hold_logo",
            "spin_back_clouds",
            "hold_clouds",
          ];
          this.loopStartIndex = 2; // after the first reveal, keep looping the spin story
          this.phaseIndex = 0;
          this.phase = this.phases[this.phaseIndex];
          this.phaseStartTime = 0;

          // Spin bookkeeping
          this.spinAngle = 0;
          this.spinStartAngle = 0;
          this.spinTargetAngle = 0;

          // Timing (seconds) for each step in the loop
          this.timing = {
            appear: 1.1,
            idle_clouds: 1,
            spin_add_cloud: 1.0,
            hold_four: 3.5,
            spin_to_logo: 1.0,
            hold_logo: 4.0,
            spin_back_clouds: 1.0,
            hold_clouds: 4.0,
          };

          // Define use the old clouds
          this.meshList = [];

          this.init();
        }

        async init() {
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            alpha: true,
            antialias: false,
          });

          this.scene = new THREE.Scene();
          this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
          this.camera.position.z = 5;
          this.scene.add(this.camera);

          this.lightPosition = new THREE.Vector3(2, 2, 2);

          this.pixelScale = 2;
          this.highRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            depthBuffer: true,
          });
          this.lowRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
          });

          const { texture, spriteCount } = await loadSymbolsTexture();
          this.asciiTexture = texture;
          this.spriteCount = spriteCount;

          this.createMaterials();
          this.createVoxelSystem();
          this.createLogo();
          this.createPostProcessing();
          this.bindEvents();
          this.resize();
          this.onPhaseEnter(this.phase);
          // this.animate();
          this.animate2();
        }

        createMaterials() {
          // Blue material for rings 1 & 2 (slightly emissive)
          this.blueMaterial = new THREE.ShaderMaterial(
            getBlueMaterialConfig(this.lightPosition, THREE.DoubleSide)
          );

          // Dark material for ring 3
          this.darkMaterial = new THREE.ShaderMaterial(
            getDarkMaterialConfig(this.lightPosition, THREE.DoubleSide)
          );

          this.rodMaterial = new THREE.ShaderMaterial(
            getRodMaterialConfig(this.lightPosition)
          );
        }

        createLogo() {
          this.meshMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_lightPosition: { value: this.lightPosition },
            },
            vertexShader: `
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            v_viewNormal = normalMatrix * normal;
                            v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                            v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        }
                    `,
            fragmentShader: `
                        uniform vec3 u_lightPosition;
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            vec3 VN = normalize(v_viewNormal);
                            vec3 N = normalize(v_worldNormal);
                            vec3 L = normalize(u_lightPosition - v_worldPosition);
                            
                            float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.5);
                            float shade2 = max(0.0, dot(VN, vec3(0.5773)));
                            gl_FragColor = vec4(shade1, shade2, 1.0, 1.0);
                        }
                    `,
          });

          this.logoCloudContainer = new THREE.Object3D();

          const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
          const cloudPositions = [
            { x: 0, y: 1.4, z: 0, scale: 1.6 }, // Top cloud (large)
            { x: -1.6, y: -1.6, z: 0.6, scale: 1.1 }, // Bottom-left cloud (LOWER)
            { x: 1.6, y: -0.8, z: -0.4, scale: 1.2 }, // Bottom-right cloud
          ];

          this.clouds = [];
          this.rods = [];

          cloudPositions.forEach((pos, index) => {
            const cloud = this.createCloud(boxGeometry, pos.scale, index);
            cloud.position.set(pos.x, pos.y, pos.z);
            this.logoCloudContainer.add(cloud);
            this.clouds.push(cloud);
          });

          // Create connecting rods between clouds
          this.createRod(cloudPositions[0], cloudPositions[1], boxGeometry); // Top to Bottom-left
          this.createRod(cloudPositions[0], cloudPositions[2], boxGeometry); // Top to Bottom-right
          this.createRod(cloudPositions[1], cloudPositions[2], boxGeometry); // Bottom-left to Bottom-right

          this.logoCloudContainer.scale.setScalar(0.38);
          this.logoOuterContainer.add(this.logoCloudContainer);
        }

        createCloud(geometry, scale, cloudIndex) {
          const cloud = new THREE.Object3D();

          // Cloud shape: stacked layers creating isometric 3D cloud effect
          // Layer configuration: [y-offset, cubes array with [x, z] positions]
          const layers = [
            // Bottom layer (darkest - back)
            {
              y: -0.4,
              cubes: [
                [-0.3, 0],
                [0.3, 0],
                [0, 0.3],
                [0, -0.3],
              ],
            },
            // Middle-back layer
            {
              y: -0.2,
              cubes: [
                [-0.5, 0],
                [0.5, 0],
                [0, 0],
                [-0.25, 0.25],
                [0.25, 0.25],
                [-0.25, -0.25],
                [0.25, -0.25],
              ],
            },
            // Middle layer
            {
              y: 0,
              cubes: [
                [-0.6, 0],
                [0.6, 0],
                [0, 0],
                [-0.3, 0],
                [0.3, 0],
                [0, 0.3],
                [0, -0.3],
                [-0.3, 0.3],
                [0.3, 0.3],
              ],
            },
            // Top layer (brightest - front)
            {
              y: 0.2,
              cubes: [
                [-0.4, 0],
                [0.4, 0],
                [0, 0],
                [-0.2, 0.2],
                [0.2, 0.2],
              ],
            },
            // Peak
            {
              y: 0.4,
              cubes: [
                [0, 0],
                [-0.2, 0],
                [0.2, 0],
              ],
            },
          ];

          const cubeSize = 0.32 * scale;

          layers.forEach((layer, layerIndex) => {
            layer.cubes.forEach((cubePos, cubeIndex) => {
              const container = new THREE.Object3D();
              const mesh = new THREE.Mesh(geometry, this.meshMaterial);

              container.position.set(
                cubePos[0] * scale,
                layer.y * scale,
                cubePos[1] * scale
              );
              container.scale.setScalar(cubeSize);
              container.add(mesh);
              cloud.add(container);

              this.meshList.push({
                mesh,
                cloudIndex,
                layerIndex,
                delay: cloudIndex * 0.3 + layerIndex * 0.05 + cubeIndex * 0.02,
              });
            });
          });

          return cloud;
        }

        createRod(from, to, geometry) {
          const rod = new THREE.Object3D();

          // Calculate direction and length
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const dz = to.z - from.z;
          const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

          // Create rod mesh
          const mesh = new THREE.Mesh(geometry, this.rodMaterial);
          const container = new THREE.Object3D();

          // Position at midpoint
          container.position.set(
            (from.x + to.x) / 2,
            (from.y + to.y) / 2,
            (from.z + to.z) / 2
          );

          // Scale to create VISIBLE rod (thicker)
          container.scale.set(0.1, 0.1, length * 0.8);

          // Rotate to point from -> to
          container.lookAt(to.x, to.y, to.z);

          container.add(mesh);
          this.logoCloudContainer.add(container);

          this.rods.push({
            mesh,
            container,
            delay: 1.5,
          });
          this.meshList.push({
            mesh,
            isRod: true,
            delay: 1.5,
          });
        }

        createVoxelSystem() {
          this.logoContainer = new THREE.Object3D();
          this.spinPivot = new THREE.Object3D();
          this.logoOuterContainer = new THREE.Object3D();

          this.boxGeometry = new THREE.BoxGeometry(0.75, 0.75, 0.75);

          // Generate positions for 3 interlocking rings (logo form)
          // const offsetX = 380;

          // this.pivotOffset = { x: 0.61, y: 0, z: 0 };

          // const centerRingByStrokeIndex = [
          //   { x: -100 + offsetX, y: 0 },
          //   { x: -85 + offsetX, y: -40 },
          //   { x: 0 + offsetX, y: 0 },
          // ];
          // const ringVoxels = this.generateItemPositions(
          //   LOGO_PATH_CONFIG,
          //   12,
          //   centerRingByStrokeIndex,
          //   true
          // );

          // // Generate positions for 4 clouds (3 base + 1 that fades in during spin)
          // const spread = 3;
          // // Adjust these anchors to shift each cloud (laid out as a rhombus; last entry = bonus cloud)
          // const cloudCenters = [
          //   { x: 220, y: -150 }, // top (pull in from edge)
          //   { x: 50, y: 30 }, // left
          //   { x: 400, y: 30 }, // right
          //   { x: 220, y: 180 }, // bottom (appears when we add the 4th cloud)
          // ];
          // const scaledCloudCenters = cloudCenters.map((p) => ({
          //   x: p.x * spread,
          //   y: p.y * spread,
          // }));

          // // const cloudVoxels = [];

          // const cloudVoxels = this.generateItemPositions(
          //   buildCloudPathConfig(scaledCloudCenters.length),
          //   5.8,
          //   scaledCloudCenters
          // );
          // cloudVoxels.forEach((cloud, cloudIndex) => {
          //   cloud.forEach((point) => {
          //     point.x = point.x - this.pivotOffset.x / (1 * 0.175);
          //     point.y = point.y - this.pivotOffset.y / (1 * 0.175);
          //     point.z = point.z - this.pivotOffset.z / (1 * 0.175);
          //   });
          // });

          // // Base anchors for rods and spinning - compute first for rod positioning
          // this.cloudAnchors = cloudVoxels.map((points) =>
          //   this.computeAnchor(points)
          // );

          // // Create rods connecting cloud centers for maximum visibility
          // this.connectRods = [];

          // this.createConnectRod(cloudVoxels[0][35], cloudVoxels[1][80]); // Top to Left
          // this.createConnectRod(cloudVoxels[0][9], cloudVoxels[2][80]); // Top to Right
          // this.createConnectRod(cloudVoxels[1][10], cloudVoxels[2][30]); // Left to Right

          // // Extra rods when 4th cloud appears
          // // this.createRod(cloudVoxels[1][20], cloudVoxels[3][45]); // Left to bottom
          // // this.createRod(cloudVoxels[2][20], cloudVoxels[3][102]); // Right to bottom

          // this.ringAnchors = ringVoxels.map((points) =>
          //   this.computeAnchor(points)
          // );
          // // Map the 4th cloud to the first ring when morphing
          // this.ringAnchors.push(this.ringAnchors[0].clone());

          // // Create voxel objects with both cloud and ring positions
          // const materials = [
          //   this.blueMaterial,
          //   this.blueMaterial,
          //   this.blueMaterial,
          //   this.darkMaterial,
          // ];

          // const groupCount = cloudVoxels.length;
          // for (let groupIndex = 0; groupIndex < groupCount; groupIndex++) {
          //   const ringPositions =
          //     ringVoxels[groupIndex % ringVoxels.length] || ringVoxels[0];
          //   const cloudPositions = cloudVoxels[groupIndex];
          //   const material = materials[groupIndex % materials.length];

          //   const maxCount = Math.max(
          //     ringPositions.length,
          //     cloudPositions.length
          //   );

          //   for (let i = 0; i < maxCount; i++) {
          //     const ringPos = ringPositions[i % ringPositions.length];
          //     const cloudPos = cloudPositions[i % cloudPositions.length];

          //     const defaultCloudPos = cloudPositions[0];

          //     const mesh = new THREE.Mesh(this.boxGeometry, material);
          //     const container = new THREE.Object3D();
          //     container.add(mesh);
          //     this.logoContainer.add(container);

          //     this.voxels.push({
          //       container,
          //       mesh,
          //       groupIndex,
          //       cloudPos: { ...cloudPos },
          //       ringPos: { ...ringPos },
          //       currentPos: { ...cloudPos },
          //       startPos: { ...defaultCloudPos },
          //       scale: 0,
          //       // delay: groupIndex * 0.25 + i * 0.01,
          //       delay: groupIndex == 0 || groupIndex == 3 ? 0 : 0.25,
          //     });
          //   }
          // }

          // this.spinPivot.position.set(
          //   this.pivotOffset.x,
          //   this.pivotOffset.y,
          //   this.pivotOffset.z
          // );

          // this.logoContainer.scale.setScalar(0.175);

          // this.spinPivot.add(this.logoContainer);
          // this.logoOuterContainer.add(this.spinPivot);
          this.scene.add(this.logoOuterContainer);
        }

        createConnectRod(from, to) {
          // Calculate direction and length with fallback for z
          const fromZ = from.z !== undefined ? from.z : 1;
          const toZ = to.z !== undefined ? to.z : 1;
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const dz = toZ - fromZ;
          const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

          const geometry = new THREE.BoxGeometry(1, 1, 1);

          // Create rod mesh
          const mesh = new THREE.Mesh(geometry, this.rodMaterial);
          const container = new THREE.Object3D();

          // Position at midpoint between two points
          container.position.set(
            (from.x + to.x) / 2,
            (from.y + to.y) / 2,
            (fromZ + toZ) / 2
          );

          // Scale to create HIGHLY VISIBLE rod - thick and bright!
          const rodThickness = 0.01; // Very thick for maximum visibility
          container.scale.set(rodThickness, rodThickness, length);

          // Rotate to point from -> to
          const targetPos = new THREE.Vector3(to.x, to.y, toZ);
          container.lookAt(targetPos);

          container.add(mesh);
          this.logoContainer.add(container);

          this.connectRods.push({
            mesh,
            container,
            delay: 1.5 * 0.45,
            length: length,
            from: { x: from.x, y: from.y, z: fromZ },
            to: { x: to.x, y: to.y, z: toZ },
          });
        }
        generateItemPositions(
          configs,
          defaultScale = 12,
          centerByStrokeIndex = [],
          customZ = undefined
        ) {
          const strokeCount =
            centerByStrokeIndex.length ||
            Math.max(...configs.map((c) => c.strokeIndex)) + 1 ||
            3;
          const strokes = Array.from({ length: strokeCount }, () => []);
          const voxelSize = 0.07;

          // SVG viewBox: 0 0 826 547, center at ~413, 273
          // Scale and transform SVG coords to our coordinate system
          const svgWidth = 826;
          const svgHeight = 547;
          const scale = defaultScale / svgWidth; // Scale to fit in ~6 units
          const offsetX = -svgWidth / 2;
          const offsetY = -svgHeight / 2;

          const transformX = (x) => (x + offsetX) * scale;
          const transformY = (y) => -(y + offsetY) * scale; // Flip Y axis

          // Helper: Add voxel to stroke (2D, flat)
          const addVoxel = (x, y, strokeIndex) => {
            const rangeLimit = 0.06;
            // const rangeLimit = 1;
            const vx = Math.round(x / voxelSize) * voxelSize;
            const vy = Math.round(y / voxelSize) * voxelSize;

            if (
              !strokes[strokeIndex].some(
                (p) =>
                  Math.abs(p.x - vx) < rangeLimit &&
                  Math.abs(p.y - vy) < rangeLimit
              )
            ) {
              strokes[strokeIndex].push({
                x: vx,
                y: vy,
                z: customZ ? (strokeIndex < 2 ? 3 : 2) : 2,
                size: voxelSize,
              });
            }
          };

          // Helper: Generate cubic bezier curve
          const generateCubicBezier = ({
            c0,
            c1,
            c2,
            c3,
            strokeIndex,
            segments = 10,
          }) => {
            const center = centerByStrokeIndex[strokeIndex] || { x: 0, y: 0 };
            const p0 = {
              x: transformX(c0.x + center.x),
              y: transformY(c0.y + center.y),
            };
            const p1 = {
              x: transformX(c1.x + center.x),
              y: transformY(c1.y + center.y),
            };
            const p2 = {
              x: transformX(c2.x + center.x),
              y: transformY(c2.y + center.y),
            };
            const p3 = {
              x: transformX(c3.x + center.x),
              y: transformY(c3.y + center.y),
            };

            // addVoxel(0, 0, strokeIndex);

            for (let i = 0; i <= segments; i++) {
              const t = i / segments;
              const pt = cubicBezier(p0, p1, p2, p3, t);

              addVoxel(pt.x, pt.y, strokeIndex);
            }
            return { x: c3.x, y: c3.y };
          };

          // Helper: Generate line
          const generateLine = (
            fx0,
            fy0,
            fx1,
            fy1,
            strokeIndex,
            segments = 6
          ) => {
            const center = centerByStrokeIndex[strokeIndex] || { x: 0, y: 0 };
            const x0 = fx0 + center.x;
            const y0 = fy0 + center.y;
            const x1 = fx1 + center.x;
            const y1 = fy1 + center.y;
            for (let i = 0; i <= segments; i++) {
              const t = i / segments;

              addVoxel(
                transformX(x0 + (x1 - x0) * t),
                transformY(y0 + (y1 - y0) * t),
                strokeIndex
              );
            }
            return { x: x1, y: y1 };
          };

          // ============================================
          // STROKE 0 (Blue): First path from SVG - Left C + Top bump + S-curve
          // Path: M 550.50 431.65 C... (the complex blue shape)
          // ============================================
          let pos = null;

          for (const stroke of configs) {
            const { strokeIndex, segments } = stroke;

            for (const seg of segments) {
              if (seg.type === "cubic") {
                pos = generateCubicBezier({
                  c0: seg.c0,
                  c1: seg.c1,
                  c2: seg.c2,
                  c3: seg.c3,
                  strokeIndex,
                  segments: seg.segments ?? 10, // default
                });
              }

              if (seg.type === "line") {
                generateLine(
                  seg.from.x,
                  seg.from.y,
                  seg.to.x,
                  seg.to.y,
                  strokeIndex
                );
                pos = seg.to;
              }
            }
          }

          return strokes;
        }

        computeAnchor(points) {
          const center = new THREE.Vector3();
          if (!points.length) return center;
          points.forEach((p) => {
            center.x += p.x;
            center.y += p.y;
            center.z += p.z || 0;
          });
          center.divideScalar(points.length);
          return center;
        }

        createPostProcessing() {
          const quadGeometry = new THREE.PlaneGeometry(2, 2);

          this.postMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_sceneTexture: { value: this.lowRenderTarget.texture },
              u_sceneTextureSize: { value: new THREE.Vector2(1, 1) },
              u_texture: { value: this.asciiTexture },
              u_textureSpriteCount: { value: this.spriteCount },
              u_bgColor: { value: this.bgColor },
              u_color: { value: this.color },
              u_mouseXY: { value: new THREE.Vector2(0, 0) },
              u_resolution: { value: new THREE.Vector2(1, 1) },
              u_brightness: { value: 1.8 },
            },
            vertexShader: `
                              varying vec2 v_uv;
                              void main() {
                                  v_uv = uv;
                                  gl_Position = vec4(position, 1.0);
                              }
                          `,
            fragmentShader: `
                              precision highp float;

                              uniform sampler2D u_sceneTexture;
                              uniform vec2 u_sceneTextureSize;
                              uniform sampler2D u_texture;
                              uniform float u_textureSpriteCount;
                              uniform vec3 u_bgColor;
                              uniform vec3 u_color;
                              uniform vec2 u_mouseXY;
                              uniform vec2 u_resolution;
                              uniform float u_brightness;

                              varying vec2 v_uv;

                              void main() {
                                  vec2 pixelXY = v_uv * u_sceneTextureSize;
                                  vec2 uv = fract(pixelXY);

                                  vec3 pixelRGB = texture2D(u_sceneTexture, floor(pixelXY) / u_sceneTextureSize).rgb;
                                  float luma = max(pixelRGB.g, (1.0 - pixelRGB.b) * 0.5);

                                  float spriteIndex = floor(min(u_textureSpriteCount * luma, u_textureSpriteCount - 1.0));


                                  vec2 spriteUV = vec2((uv.x + spriteIndex) / u_textureSpriteCount, uv.y);

                                  float sprite = texture2D(u_texture, spriteUV).g;

                                  float dist = length(u_mouseXY - vec2(v_uv.x, 1.0 - v_uv.y) * u_resolution);
                                  float distRatio = smoothstep(0.8, 0.0, dist / u_resolution.y) * pixelRGB.r;

                                  vec2 fw = fwidth(uv);
                                  sprite *= 1.0 - min(1.0, fw.x + fw.y);
                                  sprite = smoothstep(0.0, 1.0, sprite * 1.8);

                                  // BRIGHTER output
                                  vec3 brightColor = u_color * u_brightness * (1.0 + distRatio * 3.0);
                                  gl_FragColor = vec4(mix(u_bgColor, min(vec3(1.0), brightColor), sprite), 1.0);
                              }
                          `,
            extensions: { derivatives: true },
          });

          this.postQuad = new THREE.Mesh(quadGeometry, this.postMaterial);
        }

        onPhaseEnter(phase) {
          if (
            phase === "spin_add_cloud" ||
            phase === "spin_to_logo" ||
            phase === "spin_back_clouds"
          ) {
            // Start from current rotation to avoid jumps between phases
            const currentY = this.logoContainer.rotation.y;
            this.spinAngle = currentY;
            this.spinStartAngle = currentY;
            this.spinTargetAngle = currentY - Math.PI * 2; // clockwise to avoid mirrored feel
          }
        }

        onPhaseComplete(phase) {
          if (
            phase === "spin_add_cloud" ||
            phase === "spin_to_logo" ||
            phase === "spin_back_clouds"
          ) {
            this.spinAngle = this.spinTargetAngle;
          }
        }

        updatePhase(elapsed) {
          let phaseTime = elapsed - this.phaseStartTime;
          const duration = this.timing[this.phase] || 1;

          if (phaseTime >= duration) {
            this.onPhaseComplete(this.phase);
            this.phaseIndex += 1;
            if (this.phaseIndex >= this.phases.length) {
              this.phaseIndex = this.loopStartIndex;
            }
            this.phase = this.phases[this.phaseIndex];
            this.phaseStartTime = elapsed;
            this.onPhaseEnter(this.phase);
            phaseTime = 0;
          }

          return { phaseTime, duration };
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const elapsed = (Date.now() - this.startTime) / 1000;
          const delta = this.prevElapsed ? elapsed - this.prevElapsed : 0.016;
          this.prevElapsed = elapsed;
          const { phaseTime, duration } = this.updatePhase(elapsed);
          const phaseProgress = Math.min(1, phaseTime / duration);

          // Update uniforms
          this.postMaterial.uniforms.u_mouseXY.value.set(
            this.mouseX,
            this.mouseY
          );
          this.postMaterial.uniforms.u_resolution.value.set(
            this.domWidth,
            this.domHeight
          );

          // Update light
          const normalizedX = (this.mouseX / this.domWidth) * 2 - 1;
          const normalizedY = 1 - (this.mouseY / this.domHeight) * 2;
          const vec = new THREE.Vector3(normalizedX, normalizedY, 0.5);
          vec.unproject(this.camera);
          vec.z = 5;
          this.lightPosition.copy(vec);
          let mergeProgress = 0;
          let splitProgress = 0;
          let spinProgress = 0;

          let morphRaw = 0;

          const extraActivePhases = [
            "spin_add_cloud",
            "hold_four",
            "spin_to_logo",
            "hold_logo",
            "spin_back_clouds",
          ];

          const spinPhases = [
            "spin_add_cloud",
            "spin_to_logo",
            "spin_back_clouds",
          ];
          const extraActive = extraActivePhases.includes(this.phase);
          const inSpin = spinPhases.includes(this.phase);

          spinProgress = inSpin ? ease.expoInOut(phaseProgress) : 0;

          switch (this.phase) {
            case "appear":
              break;
            case "idle_clouds":
              break;
            case "spin_add_cloud":
              spinProgress = ease.expoInOut(phaseProgress);
              break;
            case "hold_four":
              break;
            case "spin_to_logo":
              mergeProgress = ease.cubicInOut(phaseProgress);
              morphRaw = mergeProgress;
              spinProgress = ease.expoInOut(phaseProgress);
              break;
            case "hold_logo":
              mergeProgress = 1;
              break;
            case "spin_back_clouds":
              splitProgress = ease.expoInOut(phaseProgress);
              morphRaw = 1 - splitProgress;
              spinProgress = inSpin ? ease.expoInOut(phaseProgress) : 0;
              break;
            case "hold_clouds":
              break;
            default:
              break;
          }

          // this.spinSmoothedY = lerp(
          //   this.spinSmoothedY,
          //   targetRotationY,
          //   rotLerp
          // );

          // Slight wobble keeps the voxel stacks lively (reduced for smoothness)
          // this.logoContainer.rotation.set(
          //   -0.05 + Math.sin(elapsed * 0.2) * 0.03,
          //   this.spinSmoothedY,
          //   Math.cos(elapsed * 0.16) * 0.03
          // );

          // Camera-facing tilt
          // this.spinPivot.rotation.set(
          //   0,
          //   (Math.PI * elapsed) % (Math.PI * 2),
          //   0
          // );

          this.logoOuterContainer.position.set(0, 0.02, 0);

          // === Center pivot for spinning: keep rotation around the visible mass ===

          const morphBlendLerp = Math.min(1, delta * 3);
          this.morphBlend = lerp(this.morphBlend, morphRaw, morphBlendLerp);

          // Re-center the container so spinPivot rotates around the mass center

          this.spinPivot.position.set(
            this.pivotOffset.x,
            this.pivotOffset.y,
            this.pivotOffset.z
          );

          this.logoContainer.position.copy(
            this.smoothedCenter.clone().multiplyScalar(-1)
          );

          if (this.phase === "appear") {
            this.connectRods.forEach((rod) => {
              const rodTime = phaseTime - rod.delay;

              const appearProgress = Math.max(
                0,
                Math.min(1, (rodTime * 1.5) / (duration - rod.delay))
              );

              const targetScaleZ = rod.length;
              const scaleZ = lerp(0.01, targetScaleZ, appearProgress);
              const rodThickness = 0.3; // Match the thickness from createRod

              rod.container.scale.set(rodThickness, rodThickness, scaleZ);
            });
          }

          // Animate voxels based on phase
          this.voxels.forEach((voxel, index) => {
            const isExtra = voxel.groupIndex === this.extraCloudIndex;
            let targetX = voxel.cloudPos.x;
            let targetY = voxel.cloudPos.y;
            let targetZ = voxel.cloudPos.z;
            let scale = 1;

            const morphDamp = 1 - this.morphBlend * 0.65;
            const bobScale = morphDamp;
            const bobX =
              (Math.sin(elapsed * 2 + index * 0.12) * 0.035 +
                Math.sin(elapsed * 0.7 + voxel.groupIndex) * 0.02) *
              bobScale;
            const bobY =
              (Math.cos(elapsed * 1.6 + index * 0.12) * 0.035 +
                Math.cos(elapsed * 0.5 + voxel.groupIndex) * 0.02) *
              bobScale;

            const morph = this.morphBlend;
            targetX = lerp(voxel.cloudPos.x, voxel.ringPos.x, morph);
            targetY = lerp(voxel.cloudPos.y, voxel.ringPos.y, morph);
            targetZ = lerp(voxel.cloudPos.z, voxel.ringPos.z, morph);

            switch (this.phase) {
              case "appear":
                const appearProgress = fit(
                  phaseTime,
                  voxel.delay * 0.45,
                  voxel.delay * 0.45 + 0.9,
                  0,
                  1,
                  ease.expoOut
                );

                let startOffset;
                switch (voxel.groupIndex) {
                  case 0:
                    startOffset = { x: 0, y: 3, z: 0 };
                    break;
                  case 1:
                    startOffset = { x: -4, y: 0, z: 0 };

                    break;
                  case 2:
                    startOffset = { x: 4, y: 0, z: 0 };

                    break;
                  case 3:
                    startOffset = { x: 0, y: -3, z: 0 };

                    break;
                  default:
                }

                targetX = lerp(
                  voxel.cloudPos.x + startOffset.x,
                  voxel.cloudPos.x,
                  appearProgress
                );
                targetY = lerp(
                  voxel.cloudPos.y + startOffset.y,
                  voxel.cloudPos.y,
                  appearProgress
                );
                targetZ = lerp(
                  voxel.cloudPos.z + startOffset.z,
                  voxel.cloudPos.z,
                  appearProgress
                );
                scale = appearProgress;
                break;
              case "idle_clouds":
                break;
              case "spin_add_cloud":
                spinProgress = ease.expoInOut(phaseProgress);
                break;
              case "hold_four":
                break;
              case "spin_to_logo":
                break;
              case "hold_logo":
                break;
              case "spin_back_clouds":
                break;
              case "hold_clouds":
                break;
              default:
                break;
            }

            voxel.container.position.set(targetX, targetY, targetZ);

            voxel.container.scale.setScalar(0.62);
          });

          // Render
          this.renderer.setRenderTarget(this.highRenderTarget);
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.clear();
          this.renderer.render(this.scene, this.camera);

          this.copyTexture();

          this.renderer.setRenderTarget(null);
          this.renderer.setClearColor(0x000000, 0);
          this.renderer.clear();
          this.renderer.render(this.postQuad, this.camera);
        }

        animate2() {
          requestAnimationFrame(() => this.animate2());

          const elapsed = (Date.now() - this.startTime) / 1000;
          const t = elapsed * 0.6; // Animation speed

          // Update mouse uniforms
          this.postMaterial.uniforms.u_mouseXY.value.set(
            this.mouseX,
            this.mouseY
          );
          this.postMaterial.uniforms.u_resolution.value.set(
            this.domWidth,
            this.domHeight
          );

          // Update light position based on mouse
          const normalizedX = (this.mouseX / this.domWidth) * 2 - 1;
          const normalizedY = 1 - (this.mouseY / this.domHeight) * 2;

          const vec = new THREE.Vector3(normalizedX, normalizedY, 0.5);
          vec.unproject(this.camera);
          vec.z = 5;
          this.lightPosition.copy(vec);

          // Animate individual cubes/meshes - FASTER appearance
          for (let i = 0; i < this.meshList.length; i++) {
            const item = this.meshList[i];
            const delay = (item.delay || i * 0.03) * 0.3; // 3x faster
            const scale = fit(t, delay, delay + 0.2, 0, 1, ease.backOut);
            item.mesh.scale.setScalar(scale);
          }

          // Clouds appear FAST and ROTATE in place
          if (this.clouds) {
            this.clouds.forEach((cloud, index) => {
              // FASTER drop-in animation
              const dropDelay = index * 0.15;
              const dropProgress = fit(
                t,
                dropDelay,
                dropDelay + 0.4,
                0,
                1,
                ease.backOut
              );
              cloud.scale.setScalar(dropProgress);

              // Self-rotation - each cloud rotates at different speed
              const rotSpeed = 0.3 + index * 0.15;
              cloud.rotation.y = elapsed * rotSpeed;

              // Slight tilt variation
              cloud.rotation.x = Math.sin(elapsed * 0.5 + index) * 0.1;
            });
          }

          // Occasional container full rotation (every 8 seconds)
          const rotationCycle = 8; // seconds
          const cycleProgress = (elapsed % rotationCycle) / rotationCycle;

          // Rotate smoothly during middle portion of cycle
          let containerRotation = 0;
          if (cycleProgress > 0.3 && cycleProgress < 0.7) {
            // Map 0.3-0.7 to 0-1, then to 0-2π
            const rotProgress = (cycleProgress - 0.3) / 0.4;
            containerRotation = ease.cubicInOut(rotProgress) * Math.PI * 2;
          } else if (cycleProgress >= 0.7) {
            containerRotation = Math.PI * 2; // Hold at full rotation briefly
          }

          this.logoCloudContainer.rotation.y = containerRotation;

          // Fixed scale
          this.logoCloudContainer.scale.setScalar(0.38);

          // Fixed outer container rotation (isometric view) - shifted MORE RIGHT
          this.logoOuterContainer.rotation.set(-0.5, Math.PI * 0.2, 0.1);
          this.logoOuterContainer.position.set(1.0, 0, 0);

          // Render to high-res target
          this.renderer.setRenderTarget(this.highRenderTarget);
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.clear();
          this.renderer.render(this.scene, this.camera);

          // Copy to low-res target (pixelation)
          this.copyTexture();

          // Render final output with ASCII effect
          this.renderer.setRenderTarget(null);
          this.renderer.setClearColor(0x000000, 0);
          this.renderer.clear();
          this.renderer.render(this.postQuad, this.camera);
        }

        copyTexture() {
          const copyMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: this.highRenderTarget.texture } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `uniform sampler2D tDiffuse; varying vec2 vUv; void main() { gl_FragColor = texture2D(tDiffuse, vUv); }`,
          });

          const copyQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            copyMaterial
          );
          this.renderer.setRenderTarget(this.lowRenderTarget);
          this.renderer.render(copyQuad, this.camera);
          copyMaterial.dispose();
          copyQuad.geometry.dispose();
        }

        bindEvents() {
          window.addEventListener("resize", () => this.resize());

          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
          });

          this.canvas.addEventListener("mouseleave", () => {
            this.mouseX = this.domWidth / 2;
            this.mouseY = this.domHeight / 2;
          });
        }

        resize() {
          const rect = this.canvas.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;

          this.domWidth = width;
          this.domHeight = height;

          const pixelSize = fit(height, 400, 1000, 12, 20);

          const pixelHeight = Math.ceil(height / pixelSize);
          const pixelWidth = Math.ceil(width / ((pixelSize * 50) / 84));
          this.lowRenderTarget.setSize(
            pixelWidth * this.pixelScale,
            pixelHeight * this.pixelScale
          );
          this.highRenderTarget.setSize(
            pixelWidth * this.pixelScale,
            pixelHeight * this.pixelScale
          );
          this.postMaterial.uniforms.u_sceneTextureSize.value.set(
            pixelWidth,
            pixelHeight
          );

          const dpr = Math.min(window.devicePixelRatio, 2);
          this.renderer.setSize(width * dpr, height * dpr, false);
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;

          const aspect = width / height;
          this.camera.left = -aspect;
          this.camera.right = aspect;
          this.camera.updateProjectionMatrix();

          this.mouseX = width / 2;
          this.mouseY = height / 2;
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        document.fonts.ready.then(() => {
          const canvas = document.getElementById("voxelCanvas");
          new VoxelLogo(canvas);
        });
      });
    </script>
  </body>
</html>
