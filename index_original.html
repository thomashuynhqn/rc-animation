<!DOCTYPE html>
<!-- saved from url=(0050)file:///C:/Users/TriVD/Desktop/3d-cusor/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Voxel Logo - Hero Section</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0d14;
            overflow: hidden;
        }

        .hero {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
        }

        #voxelCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <section class="hero">
        <div class="canvas-container">
            <canvas id="voxelCanvas" data-engine="three.js r160" width="1920" height="945" style="width: 1920px; height: 945px;"></canvas>
        </div>
    </section>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // ASCII Characters Texture Generator
        // ============================================
        function createASCIITexture() {
            const chars = ' .:-=+*#%@';
            const charWidth = 50;
            const charHeight = 84;
            const canvas = document.createElement('canvas');
            canvas.width = charWidth * chars.length;
            canvas.height = charHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 72px JetBrains Mono, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            
            for (let i = 0; i < chars.length; i++) {
                ctx.fillText(chars[i], charWidth * i + charWidth / 2, charHeight / 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return { texture, spriteCount: chars.length };
        }

        // ============================================
        // Easing Functions
        // ============================================
        const ease = {
            cubicInOut: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
            backOut: (t) => {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            },
            expoInOut: (t) => {
                if (t === 0) return 0;
                if (t === 1) return 1;
                if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
                return (2 - Math.pow(2, -20 * t + 10)) / 2;
            }
        };

        function fit(value, inMin, inMax, outMin, outMax, easeFunc = null) {
            let t = Math.max(0, Math.min(1, (value - inMin) / (inMax - inMin)));
            if (easeFunc) t = easeFunc(t);
            return outMin + (outMax - outMin) * t;
        }

        // ============================================
        // Voxel Logo Class
        // ============================================
        class VoxelLogo {
            constructor(canvas) {
                this.canvas = canvas;
                this.mouseX = 0;
                this.mouseY = 0;
                this.startTime = Date.now();
                this.meshList = [];
                
                // Colors
                this.color = new THREE.Color('#364363');
                this.bgColor = new THREE.Color('#0f131c');
                
                // Initialize
                this.init();
                this.createLogo();
                this.createPostProcessing();
                this.bindEvents();
                this.resize();
                this.animate();
            }

            init() {
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: false
                });
                
                // Scene
                this.scene = new THREE.Scene();
                
                // Camera (Orthographic for isometric view)
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
                this.camera.position.z = 5;
                this.scene.add(this.camera);
                
                // Light position (follows mouse)
                this.lightPosition = new THREE.Vector3(2, 2, 2);
                
                // Render targets for pixelation
                this.pixelScale = 2;
                this.highRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    depthBuffer: true
                });
                this.lowRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter
                });
                
                // ASCII texture
                const { texture, spriteCount } = createASCIITexture();
                this.asciiTexture = texture;
                this.spriteCount = spriteCount;
            }

            createLogo() {
                // Mesh material with lighting (for clouds - blue)
                this.meshMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        u_lightPosition: { value: this.lightPosition }
                    },
                    vertexShader: `
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            v_viewNormal = normalMatrix * normal;
                            v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                            v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 u_lightPosition;
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            vec3 VN = normalize(v_viewNormal);
                            vec3 N = normalize(v_worldNormal);
                            vec3 L = normalize(u_lightPosition - v_worldPosition);
                            
                            float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.5);
                            float shade2 = max(0.0, dot(VN, vec3(0.5773)));
                            gl_FragColor = vec4(shade1, shade2, 1.0, 1.0);
                        }
                    `
                });

                // Rod material (BRIGHT cyan/white for data connections)
                this.rodMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        u_lightPosition: { value: this.lightPosition }
                    },
                    vertexShader: `
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            v_viewNormal = normalMatrix * normal;
                            v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
                            v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 u_lightPosition;
                        varying vec3 v_worldPosition;
                        varying vec3 v_worldNormal;
                        varying vec3 v_viewNormal;
                        
                        void main() {
                            vec3 VN = normalize(v_viewNormal);
                            vec3 N = normalize(v_worldNormal);
                            vec3 L = normalize(u_lightPosition - v_worldPosition);
                            
                            float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.4);
                            float shade2 = max(0.0, dot(VN, vec3(0.5773)));
                            
                            // Bright glow effect
                            float brightness = 0.5 + shade1 * 0.3 + shade2 * 0.3;
                            gl_FragColor = vec4(brightness * 0.5, brightness * 0.7, brightness, 1.0);
                        }
                    `
                });

                const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
                
                // Logo container
                this.logoContainer = new THREE.Object3D();
                this.logoOuterContainer = new THREE.Object3D();
                
                // Cloud positions (triangle formation) - Cloud 2 moved DOWN
                const cloudPositions = [
                    { x: 0, y: 1.4, z: 0, scale: 1.6 },       // Top cloud (large)
                    { x: -1.6, y: -1.6, z: 0.6, scale: 1.1 }, // Bottom-left cloud (LOWER)
                    { x: 1.6, y: -0.8, z: -0.4, scale: 1.2 }  // Bottom-right cloud
                ];
                
                // Store cloud containers for animation
                this.clouds = [];
                this.rods = [];
                
                // Create clouds
                cloudPositions.forEach((pos, index) => {
                    const cloud = this.createCloud(boxGeometry, pos.scale, index);
                    cloud.position.set(pos.x, pos.y, pos.z);
                    this.logoContainer.add(cloud);
                    this.clouds.push(cloud);
                });
                
                // Create connecting rods between clouds
                this.createRod(cloudPositions[0], cloudPositions[1], boxGeometry); // Top to Bottom-left
                this.createRod(cloudPositions[0], cloudPositions[2], boxGeometry); // Top to Bottom-right
                this.createRod(cloudPositions[1], cloudPositions[2], boxGeometry); // Bottom-left to Bottom-right
                
                this.logoContainer.scale.setScalar(0.38);
                this.logoOuterContainer.add(this.logoContainer);
                this.scene.add(this.logoOuterContainer);
            }

            createCloud(geometry, scale, cloudIndex) {
                const cloud = new THREE.Object3D();
                
                // Cloud shape: stacked layers creating isometric 3D cloud effect
                // Layer configuration: [y-offset, cubes array with [x, z] positions]
                const layers = [
                    // Bottom layer (darkest - back)
                    { y: -0.4, cubes: [[-0.3, 0], [0.3, 0], [0, 0.3], [0, -0.3]] },
                    // Middle-back layer
                    { y: -0.2, cubes: [[-0.5, 0], [0.5, 0], [0, 0], [-0.25, 0.25], [0.25, 0.25], [-0.25, -0.25], [0.25, -0.25]] },
                    // Middle layer
                    { y: 0, cubes: [[-0.6, 0], [0.6, 0], [0, 0], [-0.3, 0], [0.3, 0], [0, 0.3], [0, -0.3], [-0.3, 0.3], [0.3, 0.3]] },
                    // Top layer (brightest - front)
                    { y: 0.2, cubes: [[-0.4, 0], [0.4, 0], [0, 0], [-0.2, 0.2], [0.2, 0.2]] },
                    // Peak
                    { y: 0.4, cubes: [[0, 0], [-0.2, 0], [0.2, 0]] }
                ];
                
                const cubeSize = 0.32 * scale;
                
                layers.forEach((layer, layerIndex) => {
                    layer.cubes.forEach((cubePos, cubeIndex) => {
                        const container = new THREE.Object3D();
                        const mesh = new THREE.Mesh(geometry, this.meshMaterial);
                        
                        container.position.set(
                            cubePos[0] * scale,
                            layer.y * scale,
                            cubePos[1] * scale
                        );
                        container.scale.setScalar(cubeSize);
                        container.add(mesh);
                        cloud.add(container);
                        
                        this.meshList.push({
                            mesh,
                            cloudIndex,
                            layerIndex,
                            delay: cloudIndex * 0.3 + layerIndex * 0.05 + cubeIndex * 0.02
                        });
                    });
                });
                
                return cloud;
            }

            createRod(from, to, geometry) {
                const rod = new THREE.Object3D();
                
                // Calculate direction and length
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const dz = to.z - from.z;
                const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                // Create rod mesh
                const mesh = new THREE.Mesh(geometry, this.rodMaterial);
                const container = new THREE.Object3D();
                
                // Position at midpoint
                container.position.set(
                    (from.x + to.x) / 2,
                    (from.y + to.y) / 2,
                    (from.z + to.z) / 2
                );
                
                // Scale to create VISIBLE rod (thicker)
                container.scale.set(0.10, 0.10, length * 0.80);
                
                // Rotate to point from -> to
                container.lookAt(to.x, to.y, to.z);
                
                container.add(mesh);
                this.logoContainer.add(container);
                
                this.rods.push({
                    mesh,
                    container,
                    delay: 1.5
                });
                this.meshList.push({
                    mesh,
                    isRod: true,
                    delay: 1.5
                });
            }

            createPostProcessing() {
                // Full-screen quad for post processing
                const quadGeometry = new THREE.PlaneGeometry(2, 2);
                
                this.postMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        u_sceneTexture: { value: this.lowRenderTarget.texture },
                        u_sceneTextureSize: { value: new THREE.Vector2(1, 1) },
                        u_texture: { value: this.asciiTexture },
                        u_textureSpriteCount: { value: this.spriteCount },
                        u_bgColor: { value: this.bgColor },
                        u_color: { value: this.color },
                        u_mouseXY: { value: new THREE.Vector2(0, 0) },
                        u_resolution: { value: new THREE.Vector2(1, 1) }
                    },
                    vertexShader: `
                        varying vec2 v_uv;
                        void main() {
                            v_uv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        precision highp float;
                        
                        uniform sampler2D u_sceneTexture;
                        uniform vec2 u_sceneTextureSize;
                        uniform sampler2D u_texture;
                        uniform float u_textureSpriteCount;
                        uniform vec3 u_bgColor;
                        uniform vec3 u_color;
                        uniform vec2 u_mouseXY;
                        uniform vec2 u_resolution;
                        
                        varying vec2 v_uv;
                        
                        void main() {
                            vec2 pixelXY = v_uv * u_sceneTextureSize;
                            vec2 uv = fract(pixelXY);
                            
                            vec3 pixelRGB = texture2D(u_sceneTexture, floor(pixelXY) / u_sceneTextureSize).rgb;
                            float luma = max(pixelRGB.g, (1.0 - pixelRGB.b) * 0.55);
                            
                            float spriteIndex = floor(min(u_textureSpriteCount * luma, u_textureSpriteCount - 1.0));
                            vec2 spriteUV = vec2((uv.x + spriteIndex) / u_textureSpriteCount, uv.y);
                            
                            float sprite = texture2D(u_texture, spriteUV).g;
                            
                            float dist = length(u_mouseXY - vec2(v_uv.x, 1.0 - v_uv.y) * u_resolution);
                            float distRatio = smoothstep(0.8, 0.0, dist / u_resolution.y) * pixelRGB.r;
                            
                            // Avoid mipmap artifacts
                            vec2 fw = fwidth(uv);
                            sprite *= 1.0 - min(1.0, fw.x + fw.y);
                            sprite = smoothstep(0.0, 1.0, sprite * 1.5);
                            
                            gl_FragColor = vec4(mix(u_bgColor, min(vec3(1.0), u_color * (0.9 + distRatio * 5.0)), sprite), 1.0);
                        }
                    `,
                    extensions: {
                        derivatives: true
                    }
                });
                
                this.postQuad = new THREE.Mesh(quadGeometry, this.postMaterial);
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    // Default to center when mouse leaves
                    this.mouseX = this.domWidth / 2;
                    this.mouseY = this.domHeight / 2;
                });
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                this.domWidth = width;
                this.domHeight = height;
                
                // Calculate pixel dimensions for ASCII effect
                const pixelSize = fit(height, 400, 1000, 14, 24);
                const pixelHeight = Math.ceil(height / pixelSize);
                const pixelWidth = Math.ceil(width / (pixelSize * 50 / 84));
                
                this.pixelWidth = pixelWidth;
                this.pixelHeight = pixelHeight;
                
                // Update render targets
                this.lowRenderTarget.setSize(pixelWidth, pixelHeight);
                this.highRenderTarget.setSize(pixelWidth * this.pixelScale, pixelHeight * this.pixelScale);
                
                // Update uniforms
                this.postMaterial.uniforms.u_sceneTextureSize.value.set(pixelWidth, pixelHeight);
                
                // Update renderer
                const dpr = Math.min(window.devicePixelRatio, 2);
                this.renderer.setSize(width * dpr, height * dpr, false);
                this.canvas.style.width = `${width}px`;
                this.canvas.style.height = `${height}px`;
                
                // Update camera
                const aspect = width / height;
                this.camera.left = -aspect;
                this.camera.right = aspect;
                this.camera.updateProjectionMatrix();
                
                // Default mouse to center
                this.mouseX = width / 2;
                this.mouseY = height / 2;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const elapsed = (Date.now() - this.startTime) / 1000;
                const t = elapsed * 0.6; // Animation speed
                
                // Update mouse uniforms
                this.postMaterial.uniforms.u_mouseXY.value.set(this.mouseX, this.mouseY);
                this.postMaterial.uniforms.u_resolution.value.set(this.domWidth, this.domHeight);
                
                // Update light position based on mouse
                const normalizedX = (this.mouseX / this.domWidth) * 2 - 1;
                const normalizedY = 1 - (this.mouseY / this.domHeight) * 2;
                
                const vec = new THREE.Vector3(normalizedX, normalizedY, 0.5);
                vec.unproject(this.camera);
                vec.z = 5;
                this.lightPosition.copy(vec);
                
                // Animate individual cubes/meshes - FASTER appearance
                for (let i = 0; i < this.meshList.length; i++) {
                    const item = this.meshList[i];
                    const delay = (item.delay || i * 0.03) * 0.3; // 3x faster
                    const scale = fit(t, delay, delay + 0.2, 0, 1, ease.backOut);
                    item.mesh.scale.setScalar(scale);
                }
                
                // Clouds appear FAST and ROTATE in place
                if (this.clouds) {
                    this.clouds.forEach((cloud, index) => {
                        // FASTER drop-in animation
                        const dropDelay = index * 0.15;
                        const dropProgress = fit(t, dropDelay, dropDelay + 0.4, 0, 1, ease.backOut);
                        cloud.scale.setScalar(dropProgress);
                        
                        // Self-rotation - each cloud rotates at different speed
                        const rotSpeed = 0.3 + index * 0.15;
                        cloud.rotation.y = elapsed * rotSpeed;
                        
                        // Slight tilt variation
                        cloud.rotation.x = Math.sin(elapsed * 0.5 + index) * 0.1;
                    });
                }
                
                // Occasional container full rotation (every 8 seconds)
                const rotationCycle = 8; // seconds
                const cycleProgress = (elapsed % rotationCycle) / rotationCycle;
                
                // Rotate smoothly during middle portion of cycle
                let containerRotation = 0;
                if (cycleProgress > 0.3 && cycleProgress < 0.7) {
                    // Map 0.3-0.7 to 0-1, then to 0-2Ï€
                    const rotProgress = (cycleProgress - 0.3) / 0.4;
                    containerRotation = ease.cubicInOut(rotProgress) * Math.PI * 2;
                } else if (cycleProgress >= 0.7) {
                    containerRotation = Math.PI * 2; // Hold at full rotation briefly
                }
                
                this.logoContainer.rotation.y = containerRotation;
                
                // Fixed scale
                this.logoContainer.scale.setScalar(0.38);
                
                // Fixed outer container rotation (isometric view) - shifted MORE RIGHT
                this.logoOuterContainer.rotation.set(-0.5, Math.PI * 0.2, 0.1);
                this.logoOuterContainer.position.set(1.0, 0, 0);
                
                // Render to high-res target
                this.renderer.setRenderTarget(this.highRenderTarget);
                this.renderer.setClearColor(0x000000, 1);
                this.renderer.clear();
                this.renderer.render(this.scene, this.camera);
                
                // Copy to low-res target (pixelation)
                this.copyTexture();
                
                // Render final output with ASCII effect
                this.renderer.setRenderTarget(null);
                this.renderer.setClearColor(0x000000, 0);
                this.renderer.clear();
                this.renderer.render(this.postQuad, this.camera);
            }

            copyTexture() {
                // Simple blit from high to low res
                const copyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: this.highRenderTarget.texture }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        varying vec2 vUv;
                        void main() {
                            gl_FragColor = texture2D(tDiffuse, vUv);
                        }
                    `
                });
                
                const copyQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), copyMaterial);
                
                this.renderer.setRenderTarget(this.lowRenderTarget);
                this.renderer.render(copyQuad, this.camera);
                
                copyMaterial.dispose();
                copyQuad.geometry.dispose();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for fonts to load
            document.fonts.ready.then(() => {
                const canvas = document.getElementById('voxelCanvas');
                new VoxelLogo(canvas);
            });
        });
    </script>



</body></html>