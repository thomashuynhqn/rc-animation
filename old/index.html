<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cloud AI – ASCII Voxel Logo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #131722;
        overflow: hidden;
      }

      .hero {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      .canvas-container {
        width: 100%;
        height: 100%;
        filter: brightness(1.3) contrast(1.08) saturate(1.08)
          drop-shadow(0 0 24px rgba(148, 175, 255, 0.22));
      }

      #voxelCanvas {
        width: 100%;
        height: 100%;
        display: block;
        cursor: crosshair;
      }

      .hero::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(
            115deg,
            rgba(46, 38, 28, 0.2) 0%,
            rgba(0, 0, 0, 0) 45%
          ),
          radial-gradient(
            circle at 35% 30%,
            rgba(150, 180, 255, 0.12),
            transparent 52%
          ),
          radial-gradient(
            circle at 75% 60%,
            rgba(150, 180, 255, 0.1),
            transparent 50%
          ),
          rgba(255, 255, 255, 0.04);
        mix-blend-mode: screen;
      }
    </style>
  </head>
  <body>
    <section class="hero">
      <div class="canvas-container">
        <canvas id="voxelCanvas" data-engine="three.js r160"></canvas>
      </div>
    </section>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      /* ---------------------------------------------
       * ASCII texture for the post-process stage
       * --------------------------------------------- */
      function createASCIITexture() {
        const chars = " .:-=+*#%@";
        const charWidth = 50;
        const charHeight = 84;
        const canvas = document.createElement("canvas");
        canvas.width = charWidth * chars.length;
        canvas.height = charHeight;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.font = "bold 72px JetBrains Mono, monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";

        for (let i = 0; i < chars.length; i++) {
          ctx.fillText(chars[i], charWidth * i + charWidth / 2, charHeight / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return { texture, spriteCount: chars.length };
      }

      /* ---------------------------------------------
       * Easing functions
       * --------------------------------------------- */
      const ease = {
        cubicInOut: (t) =>
          t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
        elasticOut: (t) => {
          const c4 = (2 * Math.PI) / 3;
          return t === 0
            ? 0
            : t === 1
            ? 1
            : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        },
      };

      function fit(value, inMin, inMax, outMin, outMax) {
        let t = (value - inMin) / (inMax - inMin);
        t = Math.max(0, Math.min(1, t));
        return outMin + (outMax - outMin) * t;
      }

      /* ---------------------------------------------
       * Generate a single fluffy cloud
       * --------------------------------------------- */
      function generateSingleCloud(centerX, centerY, centerZ, count) {
        const points = [];

        // Create realistic cloud with overlapping puffs
        const puffs = [
          { x: 0, y: 0, z: 0, r: 0.9, weight: 3 }, // center large
          { x: -0.8, y: 0.15, z: 0.1, r: 0.7, weight: 2.5 }, // left puff
          { x: 0.8, y: 0.1, z: -0.1, r: 0.65, weight: 2 }, // right puff
          { x: -0.4, y: 0.45, z: 0.15, r: 0.55, weight: 1.5 }, // top left
          { x: 0.4, y: 0.4, z: -0.05, r: 0.5, weight: 1.5 }, // top right
          { x: 0, y: 0.55, z: 0, r: 0.5, weight: 1 }, // top center
          { x: -0.2, y: -0.25, z: 0.1, r: 0.45, weight: 1 }, // bottom left
          { x: 0.2, y: -0.3, z: -0.1, r: 0.4, weight: 0.8 }, // bottom right
        ];

        const totalWeight = puffs.reduce((sum, p) => sum + p.weight, 0);

        for (let i = 0; i < count; i++) {
          // Select puff based on weight
          let random = Math.random() * totalWeight;
          let selectedPuff = puffs[0];

          for (const puff of puffs) {
            random -= puff.weight;
            if (random <= 0) {
              selectedPuff = puff;
              break;
            }
          }

          // Generate point within selected puff
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = selectedPuff.r * Math.pow(Math.random(), 0.3);

          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta) * 0.55; // Flatten
          const z = r * Math.cos(phi) * 0.7;

          points.push(
            new THREE.Vector3(
              centerX + selectedPuff.x + x,
              centerY + selectedPuff.y + y,
              centerZ + selectedPuff.z + z
            )
          );
        }

        return points;
      }

      /* ---------------------------------------------
       * Main class
       * --------------------------------------------- */
      class VoxelLogo {
        constructor(canvas) {
          this.canvas = canvas;
          this.mouseX = 0;
          this.mouseY = 0;
          this.startTime = Date.now();

          this.voxels = [];

          this.baseColor = new THREE.Color("#364363");
          this.color = this.baseColor.clone();
          this.bgColor = new THREE.Color("#0f131c");

          this.init();
          this.createLogo();
          this.createPostProcessing();
          this.bindEvents();
          this.resize();
          this.animate();
        }

        init() {
          this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            alpha: true,
            antialias: false,
          });

          this.scene = new THREE.Scene();

          this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
          this.camera.position.set(0, 0, 5);
          this.scene.add(this.camera);

          this.lightPosition = new THREE.Vector3(2, 2, 2);

          this.pixelScale = 2;
          this.highRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            depthBuffer: true,
          });
          this.lowRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
          });

          const { texture, spriteCount } = createASCIITexture();
          this.asciiTexture = texture;
          this.spriteCount = spriteCount;
        }

        createLogo() {
          const boxGeometry = new THREE.BoxGeometry(1, 1, 1);

          this.meshMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_lightPosition: { value: this.lightPosition },
            },
            vertexShader: `
        varying vec3 v_worldPosition;
        varying vec3 v_worldNormal;
        varying vec3 v_viewNormal;
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          v_viewNormal = normalMatrix * normal;
          v_worldNormal = normalize((vec4(v_viewNormal, 0.0) * viewMatrix).xyz);
          v_worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
        }
      `,
            fragmentShader: `
        uniform vec3 u_lightPosition;
        varying vec3 v_worldPosition;
        varying vec3 v_worldNormal;
        varying vec3 v_viewNormal;
        void main() {
          vec3 VN = normalize(v_viewNormal);
          vec3 N  = normalize(v_worldNormal);
          vec3 L  = normalize(u_lightPosition - v_worldPosition);

          float shade1 = max(0.0, dot(N, L)) / (length(u_lightPosition - v_worldPosition) * 0.5);
          float shade2 = max(0.0, dot(VN, vec3(0.5773)));

          gl_FragColor = vec4(shade1, shade2, 1.0, 1.0);
        }
      `,
          });

          this.logoContainer = new THREE.Object3D();
          this.logoOuterContainer = new THREE.Object3D();

          this.logoOuterContainer.rotation.set(0, 0, 0);
          this.logoOuterContainer.position.set(0, -0.05, 0);
          this.logoOuterContainer.scale.setScalar(0.32);

          this.logoOuterContainer.add(this.logoContainer);
          this.scene.add(this.logoOuterContainer);

          // -----------------------------------------
          // BUILD C3 LOGO following the red lines exactly
          // -----------------------------------------
          const shape1Points = []; // Left "C" shape
          const shape2Points = []; // Top curve + middle "3"
          const shape3Points = []; // Right curve + bottom

          const addArc = (points, cx, cy, r, startDeg, endDeg, count) => {
            const startRad = (startDeg * Math.PI) / 180;
            const endRad = (endDeg * Math.PI) / 180;
            for (let i = 0; i < count; i++) {
              const t = count === 1 ? 0 : i / (count - 1);
              const a = startRad + (endRad - startRad) * t;
              const x = cx + r * Math.cos(a);
              const y = cy + r * Math.sin(a);
              points.push(new THREE.Vector3(x, y, 0));
            }
          };

          const addLine = (points, x1, y1, x2, y2, count) => {
            for (let i = 0; i < count; i++) {
              const t = count === 1 ? 0 : i / (count - 1);
              const x = x1 + (x2 - x1) * t;
              const y = y1 + (y2 - y1) * t;
              points.push(new THREE.Vector3(x, y, 0));
            }
          };

          // SHAPE 1: LEFT "C" - Large blue circular arc (opens right)
          addArc(shape1Points, -2.4, 0.1, 1.75, 40, 320, 250);

          // SHAPE 2: TOP + MIDDLE "3"
          // Top large arc
          addArc(shape2Points, -0.2, 2.0, 2.0, -155, 65, 200);
          // Upper middle curve of "3"
          addArc(shape2Points, 0.7, 0.6, 1.3, 70, 290, 150);
          // Lower middle curve of "3"
          addArc(shape2Points, 0.8, -0.8, 1.65, 80, 280, 160);
          // Vertical connector in middle
          addLine(shape2Points, 0.65, -2.1, 0.65, -2.4, 25);

          // SHAPE 3: RIGHT + BOTTOM
          // Right arc
          addArc(shape3Points, 2.4, -0.1, 1.95, -70, 120, 180);
          // Bottom horizontal line
          addLine(shape3Points, 0.8, -2.55, 4.2, -2.55, 100);
          // Small connector at bottom left
          addLine(shape3Points, 0.65, -2.4, 0.8, -2.55, 15);

          // -----------------------------------------
          // CREATE THREE CLOUDS IN TRIANGLE FORMATION
          // -----------------------------------------

          // Triangle positions for clouds
          const cloud1Center = { x: -2.8, y: 1.2, z: 0.2 }; // Top left
          const cloud2Center = { x: 0.8, y: 1.8, z: -0.2 }; // Top right
          const cloud3Center = { x: 0.0, y: -1.5, z: 0.1 }; // Bottom center

          const cloud1Count = shape1Points.length;
          const cloud2Count = shape2Points.length;
          const cloud3Count = shape3Points.length;

          const cloud1Points = generateSingleCloud(
            cloud1Center.x,
            cloud1Center.y,
            cloud1Center.z,
            cloud1Count
          );
          const cloud2Points = generateSingleCloud(
            cloud2Center.x,
            cloud2Center.y,
            cloud2Center.z,
            cloud2Count
          );
          const cloud3Points = generateSingleCloud(
            cloud3Center.x,
            cloud3Center.y,
            cloud3Center.z,
            cloud3Count
          );

          this.voxels = [];

          // Cloud 1 -> Shape 1
          for (let i = 0; i < cloud1Count; i++) {
            const mesh = new THREE.Mesh(boxGeometry, this.meshMaterial);
            mesh.position.copy(cloud1Points[i]);
            mesh.scale.setScalar(0);
            this.logoContainer.add(mesh);

            this.voxels.push({
              mesh,
              cloudPos: cloud1Points[i],
              finalPos: shape1Points[i],
              cloudIndex: 0,
            });
          }

          // Cloud 2 -> Shape 2
          for (let i = 0; i < cloud2Count; i++) {
            const mesh = new THREE.Mesh(boxGeometry, this.meshMaterial);
            mesh.position.copy(cloud2Points[i]);
            mesh.scale.setScalar(0);
            this.logoContainer.add(mesh);

            this.voxels.push({
              mesh,
              cloudPos: cloud2Points[i],
              finalPos: shape2Points[i],
              cloudIndex: 1,
            });
          }

          // Cloud 3 -> Shape 3
          for (let i = 0; i < cloud3Count; i++) {
            const mesh = new THREE.Mesh(boxGeometry, this.meshMaterial);
            mesh.position.copy(cloud3Points[i]);
            mesh.scale.setScalar(0);
            this.logoContainer.add(mesh);

            this.voxels.push({
              mesh,
              cloudPos: cloud3Points[i],
              finalPos: shape3Points[i],
              cloudIndex: 2,
            });
          }

          // Animation timing
          this.holdTime = 2.0; // Hold still before merge
          this.mergeTime = 0.5; // Sudden merge
          this.logoHoldTime = 2.5; // Hold logo
          this.unmergeTime = 0.5; // Sudden unmerge
          this.cycleTime =
            this.holdTime +
            this.mergeTime +
            this.logoHoldTime +
            this.unmergeTime;
        }

        createPostProcessing() {
          this.postScene = new THREE.Scene();
          this.postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

          const quadGeometry = new THREE.PlaneGeometry(2, 2);

          this.postMaterial = new THREE.ShaderMaterial({
            uniforms: {
              u_sceneTexture: { value: this.lowRenderTarget.texture },
              u_sceneTextureSize: { value: new THREE.Vector2(1, 1) },
              u_texture: { value: this.asciiTexture },
              u_textureSpriteCount: { value: this.spriteCount },
              u_bgColor: { value: this.bgColor },
              u_color: { value: this.color },
              u_mouseXY: { value: new THREE.Vector2(0, 0) },
              u_resolution: { value: new THREE.Vector2(1, 1) },
            },
            vertexShader: `
        varying vec2 v_uv;
        void main() {
          v_uv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        precision highp float;

        uniform sampler2D u_sceneTexture;
        uniform vec2 u_sceneTextureSize;
        uniform sampler2D u_texture;
        uniform float u_textureSpriteCount;
        uniform vec3 u_bgColor;
        uniform vec3 u_color;
        uniform vec2 u_mouseXY;
        uniform vec2 u_resolution;

        varying vec2 v_uv;

        void main() {
          vec2 pixelXY = v_uv * u_sceneTextureSize;
          vec2 uv = fract(pixelXY);

          vec3 pixelRGB = texture2D(u_sceneTexture, floor(pixelXY) / u_sceneTextureSize).rgb;
          float luma = max(pixelRGB.g, (1.0 - pixelRGB.b) * 0.55);

          float spriteIndex = floor(min(u_textureSpriteCount * luma, u_textureSpriteCount - 1.0));
          vec2 spriteUV = vec2((uv.x + spriteIndex) / u_textureSpriteCount, uv.y);
          float sprite = texture2D(u_texture, spriteUV).g;

          float dist = length(u_mouseXY - vec2(v_uv.x, 1.0 - v_uv.y) * u_resolution);
          float distRatio = smoothstep(0.8, 0.0, dist / u_resolution.y) * pixelRGB.r * 2.4;

          vec2 fw = fwidth(uv);
          sprite *= 1.0 - min(1.0, fw.x + fw.y);
          sprite = smoothstep(0.0, 1.0, sprite * 1.5);

          vec3 glowColor = min(vec3(1.0), u_color * (1.05 + distRatio * 6.0 + sprite * 0.3));
          gl_FragColor = vec4(mix(u_bgColor, glowColor, sprite), 1.0);
        }
      `,
            extensions: { derivatives: true },
          });

          this.postQuad = new THREE.Mesh(quadGeometry, this.postMaterial);
          this.postScene.add(this.postQuad);
        }

        bindEvents() {
          window.addEventListener("resize", () => this.resize());

          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
          });

          this.canvas.addEventListener("mouseleave", () => {
            this.mouseX = this.domWidth / 2;
            this.mouseY = this.domHeight / 2;
          });
        }

        resize() {
          const rect = this.canvas.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;

          this.domWidth = width;
          this.domHeight = height;

          const pixelSize = fit(height, 400, 1000, 14, 24);
          const pixelHeight = Math.ceil(height / pixelSize);
          const pixelWidth = Math.ceil(width / (pixelSize * (50 / 84)));

          this.lowRenderTarget.setSize(pixelWidth, pixelHeight);
          this.highRenderTarget.setSize(
            pixelWidth * this.pixelScale,
            pixelHeight * this.pixelScale
          );

          this.postMaterial.uniforms.u_sceneTextureSize.value.set(
            pixelWidth,
            pixelHeight
          );
          this.postMaterial.uniforms.u_resolution.value.set(width, height);

          const aspect = width / height;
          this.camera.left = -aspect;
          this.camera.right = aspect;
          this.camera.top = 1;
          this.camera.bottom = -1;
          this.camera.updateProjectionMatrix();

          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          this.renderer.setSize(width * dpr, height * dpr, false);
          this.renderer.setPixelRatio(dpr);
          this.canvas.style.width = width + "px";
          this.canvas.style.height = height + "px";

          this.mouseX = width / 2;
          this.mouseY = height / 2;
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const elapsed = (Date.now() - this.startTime) / 1000;

          this.postMaterial.uniforms.u_mouseXY.value.set(
            this.mouseX,
            this.mouseY
          );

          // Move light with mouse
          const nx = (this.mouseX / this.domWidth) * 2 - 1;
          const ny = 1 - (this.mouseY / this.domHeight) * 2;
          const vec = new THREE.Vector3(nx, ny, 0.5);
          vec.unproject(this.camera);
          vec.z = 5;
          this.lightPosition.copy(vec);

          // ----------------------------
          // ANIMATION CYCLE
          // ----------------------------
          const cyclePos = (elapsed % this.cycleTime) / this.cycleTime;
          let mergePhase = 0;

          if (cyclePos < this.holdTime / this.cycleTime) {
            mergePhase = 0;
          } else if (
            cyclePos <
            (this.holdTime + this.mergeTime) / this.cycleTime
          ) {
            const t =
              (cyclePos - this.holdTime / this.cycleTime) /
              (this.mergeTime / this.cycleTime);
            mergePhase = ease.cubicInOut(t);
          } else if (
            cyclePos <
            (this.holdTime + this.mergeTime + this.logoHoldTime) /
              this.cycleTime
          ) {
            mergePhase = 1;
          } else {
            const t =
              (cyclePos -
                (this.holdTime + this.mergeTime + this.logoHoldTime) /
                  this.cycleTime) /
              (this.unmergeTime / this.cycleTime);
            mergePhase = 1 - ease.cubicInOut(t);
          }

          // Appear animation
          const appearDuration = 1.2;
          const appearPhase = Math.min(1, elapsed / appearDuration);
          const appearEased = ease.elasticOut(appearPhase);

          for (const v of this.voxels) {
            const { mesh, cloudPos, finalPos } = v;

            const baseScale = 0.11;
            const scale = baseScale * appearEased;
            mesh.scale.setScalar(scale);

            mesh.position.lerpVectors(cloudPos, finalPos, mergePhase);
          }

          // Render
          this.renderer.setRenderTarget(this.highRenderTarget);
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.clear();
          this.renderer.render(this.scene, this.camera);

          this.copyTexture();

          this.renderer.setRenderTarget(null);
          this.renderer.setClearColor(0x000000, 0);
          this.renderer.clear();
          this.renderer.render(this.postScene, this.postCamera);
        }

        copyTexture() {
          const copyMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: this.highRenderTarget.texture } },
            vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.0);
        }
      `,
            fragmentShader: `
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
          gl_FragColor = texture2D(tDiffuse, vUv);
        }
      `,
          });

          const copyQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            copyMaterial
          );
          const copyScene = new THREE.Scene();
          const copyCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
          copyScene.add(copyQuad);

          this.renderer.setRenderTarget(this.lowRenderTarget);
          this.renderer.render(copyScene, copyCamera);

          copyMaterial.dispose();
          copyQuad.geometry.dispose();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        document.fonts.ready.then(() => {
          const canvas = document.getElementById("voxelCanvas");
          new VoxelLogo(canvas);
        });
      });
    </script>
  </body>
</html>
